# 1. 递归是什么？
递归：函数的自我调用。
原理：如果一个函数可以求 $A(n)$ ，那么该函数就可以求 $A(n - 1)$，从而形成了递归。
递归函数：可以理解为一个**功能函数**，即解决哪一个问题。
**注意**： 一般**起始项**不需要求解，是已知条件。

## 1.1 递归求解问题的步骤
1. 第一步：找出规律
2. 第二步：函数调用自己求解前面的项。
3. 第三步：交代起始项，使递归结束。

## 1.2 递归的重要思想
- 既然函数 $fun()$ 可以求出第 $n$ 项，那么它就可以求解出来第 $n - 1$ 项，也能求解出来第 $n + 1$ 项。
- 既然函数 $fun()$ 能够解决一个问题的第 $n$ 步，就能解决第 $n - 1$ 步，也能解决第 $n + 1$ 步。

## 1.3 递归算法解决问题的特点
1. 递归就是再问题解决的过程中或者函数里调用自身。
2. 在使用递归策略时，<u> 必须有一个明确的递归结束条件</u>，称为递归出口。
3. 递归算法通常显得很简洁，但是递归算法运行效率较低。所以一般不提倡用递归算法设计程序。
4. 递归调用的过程中，计算机系统会为每一层的返回点，局部变量等都开辟了栈来存储。递归层数过多容易造成栈溢出。
综上四点，如果递归可以等价的转换为循环，尽量使用循环！！！

## 2.值传递与指针传递
地址：变量在内存中的编号。 比如，数组的本质是 $a[0]$ 的地址！
指针：地址在 $C++$ 中被称为指针。
```cpp
#include <iostream>
using namespace std;
/*
* @Author: Yanpb
* @example: 值传递与地址传递
*/

void func1(int num) {
    num += 2;
}

// 数组传递的是地址
void func2(int num[]) {
    num[0] *= 10;
}
  
int main() {
    // 1. 值传递 无法修改
    int num = 1;
    func1(num);
    cout << num << endl;

    // 2. 指针传递 可以修改
    int a[5] = {3};
    a[0] = 1;
    cout << a[0] << endl;

    // 3. 指针传递 可以修改
    func2(a);
    cout << a[0] << endl;
    return 0;
}
```

## 3. 递归样例

$Problem$: 定义函数，递归求解等差数列$1$，$4$， $10$，$13$......到第$n$项。
$Solved$:

递归规律：$f(n) = f(n - 1) + 3$。
递归出口：当计算到第$n$项时，停止。
代码：
```cpp
#include <iostream>
using namespace std;
/*
* @Author: Yanpb
* @Question: f(n) = f(n - 1) + 3
* @Function: 返回等差数列的第 n 项。
* @example: f(5) = f(4) + 3 = 13;
*           f(4) = f(3) + 3 = 10;
*           f(3) = f(2) + 3 = 7;        
*           f(2) = f(1) + 3 = 4;
*           f(1) = 1;
*/
int f(int n) {
    int res = 0;
    if(n == 1) {
        res = 1;
    } else {
        res = f(n - 1) + 3;
    }
    return res;
}

int main() {
    int n; 
    cin >> n;
    for (int i = 1; i <= n; i ++)
        cout << f(i) << endl;
    return 0;
}
```
内存分配：
## 3. 递归习题
1. 【入门】编程求解 $1 + 2 + 3 + 4+ ... + n$。
解法一：使用公共变量，将每次递归产生的变量 $i$，加到总和 $sum$ 上。
```cpp

```