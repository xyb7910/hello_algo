# 双指针
双指针顾名思义，指在遍历对象的过程中，不是一个指针进行访问，而是使用两个方向相同的指针（快慢指针）或者两个方向相反的指针（对撞指针）进行扫描，来达到目的。<br>
## 快慢指针
使两个指针从同一侧开始遍历，两个指针的定义分别为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的方法进行移动（快指针每次增加2，慢指针每次增加1），直到两个指针的值相等或者满足其他结束条件时为止。
## 对撞指针
主要应用在有序的数组中，定义两个指针，一个指向最左侧的索引定义为`左指针（left）`，最右侧的定义为`右指针（right）`，然后两个指针向中间移动，直至相撞为止。<br>
## 常见问题分类
   (1) 对于一个序列，用两个指针维护一段区间;<br>
  (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作。 <br>
  
**算法模板**
```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
    // 具体问题的逻辑
}
```
## 例题
### LeetCode 283.移动零
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

 
```c++
示例 1:
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:
输入: nums = [0]
输出: [0]
```

提示:

- $\ce{1 <= nums.length <= 10^4}$
- $\ce{-2^31 <= nums[i] <= 2^31 - 1}$

### 题意分析

我们要将非零元素移动到数组的前边，把零元素移动到数组的后方。

所以我们可以设置**快慢指针**，让`j`指针始终直指非零元素，让`i`指针逐次才能够后移动。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;//j的初始位置在0处
        for (int i = 0; i < nums.size(); i ++) {
            if(nums[i] != 0) //如果当前元素不等于0时，我们把j指针向后移动
                nums[j ++] = nums[i];
        }

        for (int i = j; i < nums.size(); i ++) nums[i] = 0; //最终j指针指向最后一个非零元素，我们要向其后边补零
    }
};
```
### LeetCode 167.两数之和II-输入有序数组
给你一个下标从**1**开始的整数数组`numbers`，该数组已按**非递减顺序排列**，请你从数组中找出满足相加之和等于目标数`target`的两个数。如果设这两个数分别是`numbers[index1]`和`numbers[index2]`，则`1 <= index1 < index2 <= numbers.length`。

以长度为`2`的整数数组`[index1, index2]`的形式返回这两个整数的下标`index1`和`index2`。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

``` c++
示例 1
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

示例 2：
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。

示例 3：
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

提示：

- $\ce{2 <= numbers.length <= 3 * 10^4}$
- $\ce{-1000 <= numbers[i] <= 1000}$
- numbers 按**非递减顺序**排列
- $\ce{-1000 <= target <= 1000}$
- **仅存在一个有效答案**


### 题意分析

数组以非递减的顺序排列，我们可以设置两个指针，一个位于数组的首部指针`l`，一个位于数组的尾部`r`，我们让`number[l] + number[j] = num`,如果我们发现`num == target`时，我们输出下标即可。当我们发现`num < target`时，因为数组是得递减的，所以我们可以将首部指针`l`向后移动一位，直至`num == target`为止。当`num > target`时，将尾部指针`r`向前移动一位即可。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int l = 0, r = numbers.size() - 1;
        while(l < r) {
            int num = numbers[l] + numbers[r];
            if(num == target) return {l + 1, r + 1};
            if(num < target) l ++;
            else r --;
        }
        return {-1, -1};
    }
};
```
## 总结

双指针算法主要是一种解题的方法，两个指针指向不同的条件，但两个指针又存在制约关系，我们可以使用双指针算法快速求解。

 