
## 一维差分
### 问题引入
在这之前你一定知道了最简单的前缀和，我们再来了解一下什么是差分。

给你一串长度为`n`的数列a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>......a<sub>n</sub>，要求对a[L]~a[R]进行`m`次操作：

操作一：将a[L]~a[R]内的元素都加上`c`

操作二：将a[L]~a[R]内的元素都减去`c`

最后再给出一个询问求a[L]-a[R]内的元素之和？

你会怎么做呢？你可能会想，我对于m次操作每次都遍历一遍a[L]~a[R],给区间里的数都加上`c`或减去`c`，最后再求一次前缀和就行了。

没错，这样子确实也能得出正确答案，但时间复杂度却高达$\ce{O(m*n)}$，对于$\ce{1<=n,m<=10^5}$这个数据范围来说直接就GG了，所以说这个方法不可行。既然这样不行的话，那我们要怎么做才能快速的得到正确答案呢？是的，这个时候我们的差分就该派上用场了，我们新开一个数组`b`，储存每一次的修改操作，最后求前缀和的时候统计一下就能快速的得到正确答案了。<br>
### 一维差分思想
给定一个原数组`a`：a[1], a[2], a[3]... a[n]

然后构造一个数组`b` :b[1] ,b[2] ,b[3]...b[i]

使得a[i] = b[1] + b[2 ]+ b[3] +...+ b[i]

也就是说，`a`数组是`b`数组的前缀和数组，反过来我们把`b`数组叫做`a`数组的差分数组。

换句话说，每一个`a[i]`都是`b`数组中从头开始的一段区间和。

![一维差分](https://files.mdnice.com/user/34286/7bff906f-19b2-4c82-914c-a7374f62f205.png)
看完了一维差分的原理，哈哈，能看懂吧，我的字就那样，正在努力改善。下面就来看看一维差分的模板吧。


 ### 一维差分模板
 ```c++
 //给区间[l, r]中的每个数加上c,相当于给差分数组的两端加上或减去一个数：
B[l] += c, B[r + 1] -= c
 ```
 
 
 
 ## 二维差分
 二维差分与一维类似。
 
 ![](https://files.mdnice.com/user/34286/1a656b81-f247-4876-8b93-d6f39112e951.png)

 
**原理：**<br>
`b[x1][ y1 ] +=c `: 对应图1 ,让整个`a`数组中蓝色矩形面积的元素都加上了`c`。<br>
`b[x1,][y2+1]-=c` : 对应图2 ,让整个`a`数组中绿色矩形面积的元素再减去`c`，使其内元素不发生改变。<br>
`b[x2+1][y1]- =c `: 对应图3 ,让整个`a`数组中紫色矩形面积的元素再减去`c`，使其内元素不发生改变。<br>
`b[x2+1][y2+1]+=c`: 对应图4,,让整个`a`数组中红色矩形面积的元素再加上`c`，红色内的相当于被减了两次，再加上一次`c`，才能使其恢复。<br>
![](https://files.mdnice.com/user/34286/390f2438-9024-416b-b84c-ba0f0e4530f7.png)

 
 **二维差分模板**
```c++
//给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
## 总结

前缀和与差分的题型很灵活，我们要多刷题，在刷题中总结前缀和的使用与差分的判断。

这里我们给出的在某个位置加上一个数是最基本的差分，提升还要靠读者自己。


