
## 一维前缀和
### 问题因入
如果我给你一串长度为`n`的数列a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>......a<sub>n</sub>,再给出`m`个询问，每次询问给出`L`，`R`两个数，要求给出区间[L,R]里的数的和，你会怎么做，若是没有了解过前缀和的人看到这道题的想法可能是对于`m`次询问，我每次都遍历一遍它给的区间，计算出答案，这样子的方法固然没错，但是其时间复杂度达到了$\ce{O(n*m)}$，如果数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到$\ce{O(n + m)}$,大大节省了运算时间。

**前缀和**顾名思义就是前面`i`个数的总和。数组`a`在经过这样的操作之后，对于每次的询问，我们只需要计算a[R]-a[L-1]就能得到我们想要的答案了，是不是很简单呢。
### 一维前缀和思想
![](https://files.mdnice.com/user/34286/ffd728e1-ddfe-4ed2-b3e2-b5371fa9b5ea.png)
原数组: a[1], a[2], a[3], a[4], a[5], …, a[n]

前缀和: S[i] = a[1] + a[2] + a[3] + … + a[i]

注意: 前缀和的下标一定要从`1`开始, 避免进行下标的转换。<br>
`s[0] = 0`<br>
`s[1] = a[1]`<br>
`s[2] = a[1] + a[2]`<br>
`...`<br>
### 前缀和的作用
快速求出元素组中某段区间的和<br>

### 一维前缀和模板

```c++
//S[i] = a[1] + a[2] + ... a[i]
//a[l] + ... + a[r] = S[r] - S[l - 1]
for(int i=1;i<=n;i++)
   a[i]+=a[i-1];
```
~~讲完了一维前缀和，接下来，咱们就来看看什么叫二维前缀和吧。~~
## 二维前缀和
给定一个`n*m`大小的矩阵`a`，有`k`次询问，每次询问给定`x1`,`y1`,`x2`,`y2`四个数，求以`(x1,y1)`为左上角坐标和`(x2,y2)`为右下角坐标的子矩阵的所有元素和。

与一维的前缀和类似，我们也可以暴力去求解，以此计算出矩阵内的各个元素相加，如果出现的数据范围很大时，我们必然会GG了，所以有没有一种快速的方法去求解呢。

当然了，是有的，没有的话我在这里讲什么。

顾名思义就是在编程中就是为一个二维矩阵的前缀和,在讲前缀和之前我们先来看看怎么求出一个子矩阵的和吧。
![](https://files.mdnice.com/user/34286/1a87750a-3701-4dd3-bd4e-b2ceebb22ba7.png)
看完了子矩阵的求和，紧接着来看看怎么求以`(x1,y1)`为左上角坐标和`(x2,y2)`为右下角坐标的子矩阵的所有元素和。
![](https://files.mdnice.com/user/34286/127c8419-27a8-40bb-bc6f-af849cda547c.png)
 ### 二维子矩阵和模板
```c++
//S[i, j] = 第i行j列格子左上部分所有元素的和
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
```
 
 ### 二维前缀和模板
```c++
//以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

