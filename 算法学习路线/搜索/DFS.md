
> 一条路走到底，不撞南墙不回头，深度优先算法就是一个这样的‘莽夫’，然而就是一位这样的‘莽夫’，却是我们刷算法题的一个必不可少的制胜法宝。 -ypb

### 描述
即深度优先遍历，是图论与树中的经典算法。使用深度优先遍历，可以方便的产生目标图的相关拓扑排序表。

**拓扑排序表**是我们常用用来解决图论问题的有力工具。一般常用**栈**来作为辅助去求解DFS问题，其过程简单的来说是**对每一个可能的分支深入到不能再深入为止，并且每一个节点我们只能访问一次**。

看了上边的苦涩难懂的文字，用生活中的栗子来说明。

DFS相当于一个很钟情的男人，不撞南墙不回头的那种。非要把一条路走到黑。只要有向前走的机会他就会一直向前走。但是DFS也不傻，对于有时候理智的话，他觉得没希望了就提前结束（专业叫“剪枝”）。

### 特点

- 只要前面有可以走的路，那就一直往前走，直到无路可走才会回头。
- **无路可走**包含两种情况，其一则是**撞墙**，其二则是**遇到已经走过的路**
- 在**无路可走**的时候，沿着原路返回，直到回到了还有未走过的路的路口，尝试继续走没有走过的路径；
- 深度优先遍历并不一定会走完所有的路径，如果找到了出口，就代表已经可以结束了。


<font color = green>绿的的部分为DFS的遍历顺序</font>
![](https://files.mdnice.com/user/34286/e9cbb1a5-906f-4bc0-8857-8631c2cd4e1c.png)
**技巧:** 每一个DFS都有一棵与之对应的递归搜索树，我们可以借助画图来帮我们理清思路。
### 基本框架
```c++
//DFS基本框架
void DFS()
{
    if(到达终点)
    {
        ...//根据问题
        return;
    }
    if(越界/不合法的条件) return;
    if(特殊条件/剪枝条件) //剪枝
                return;
                
    for(扩展方式)
    {
        if(扩展方式到的合法状态)
        {
            修改操作;
            标记;
            DFS(下一步);
            还原现场;
        }
    }
}
```
<font color = red>强调:</font>

1. <font color = red>访问路径要正确。</font>根据不同的题目思考怎么样才是一条正确的访问路径，如何实现遍历。
2. <font color = red>起点条件。</font>开始从哪个点访问？是否每个点我们都能当成起点？
3. <font color = red>递归参数。</font>简单来说，我们怎样才能在这次递归与下一次递归建立一个桥梁，而这个桥梁是有某些参数建立起来的。我们需要知道一条路径上各个节点之间的关系。
4. <font color = red>结束条件。</font>访问的停止条件是什么？大多数到达边界条件为所有顶点已全部遍历。结束条件需要在下一次递归前判断，所以放在了DFS前部。
5. <font color = red>访问的标志。</font>在遍历的时候，为了避免一个节点被重复访问，我们需要对已经访问过的节点打上一个标记。
6. <font color = red>必要情况下的剪枝。</font>这一步相当于算法优化了。剪枝的判断在于提前终止递归优化时间复杂性。

## 例题
**1.全排列**

把 `1∼n` 这 `n` 个整数排成一行后随机打乱顺序，输出所有可能的次序。

分析
```c++
1. 访问路径：从起始位置到每一个叶节点都为一个排列，即一条路径。
2. 起始条件：起始位置为第一个数的情况，此后共有n个节点。
3. 递归参数：当前节点在排列中的位置。
4. 结束条件：当访问到的节点数为n时，表示已全部遍历，停止递归。
```

这里我们以`3`个数为例进行解释：


![](https://files.mdnice.com/user/34286/b89cc5d2-cb63-4834-9fe3-6a60a217b037.png)

假设有 `3` 个空位，从前往后填数字，每次填一个位置，填的数字不能和前面一样。

最开始的时候，三个空位都是空的：_  _ _

首先填写第一个空位，第一个空位可以填 `1`，填写后为：`1` _ _

填好第一个空位，填第二个空位，第二个空位可以填 `2`，填写后为：`1` `2` _

填好第二个空位，填第三个空位，第三个空位可以填 `3`，填写后为： `1` `2` `3`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`1` `2` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `3` ，没有其他数字可以填。

因此再往后退一步，退到了状态：`1` _ _。第二个空位上除了填过的 `2`，还可以填 `3`。第二个空位上填写 `3`，填写后为：`1` `3` _

填好第二个空位，填第三个空位，第三个空位可以填 `2`，填写后为： `1` `3` `2`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`1` `3` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `2`，没有其他数字可以填。

因此再往后退一步，退到了状态：`1` _ _。第二个空位上除了填过的 `2`，`3`，没有其他数字可以填。

因此再往后退一步，退到了状态：_ _ _。第一个空位上除了填过的 `1`，还可以填 `2`。第一个空位上填写 `2`，填写后为：`2` _ _

填好第一个空位，填第二个空位，第二个空位可以填 `1`，填写后为：`2` `1` _

填好第二个空位，填第三个空位，第三个空位可以填 `3`，填写后为：`2` `1` `3`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`2` `1` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `3`，没有其他数字可以填。

因此再往后退一步，退到了状态：`2` _ _。第二个空位上除了填过的 `1`，还可以填 `3`。第二个空位上填写 `3`，填写后为：`2` `3` _

填好第二个空位，填第三个空位，第三个空位可以填 `1`，填写后为：`2` `3` `1`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`2` `3` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `1`，没有其他数字可以填。

因此再往后退一步，退到了状态：`2` _ _。第二个空位上除了填过的 `1`，`3`，没有其他数字可以填。

因此再往后退一步，退到了状态：_ _ _。第一个空位上除了填过的 `1`，`2`，还可以填 `3`。第一个空位上填写 `3`，填写后为：`3` _ _

填好第一个空位，填第二个空位，第二个空位可以填 `1`，填写后为：`3` `1` _

填好第二个空位，填第三个空位，第三个空位可以填 `2`，填写后为：`3` `1` `2`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`3` `1` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `2`，没有其他数字可以填。

因此再往后退一步，退到了状态：`3` _ _。第二个空位上除了填过的 `1`，还可以填 `2`。第二个空位上填写 `2`，填写后为：`3` `2` _

填好第二个空位，填第三个空位，第三个空位可以填 `1`，填写后为：`3` `2` `1`

这时候，空位填完，无法继续填数，所以这是一种方案，输出。

然后往后退一步，退到了状态：`3` `2` _ 。剩余第三个空位没有填数。第三个空位上除了填过的 `1`，`2`，没有其他数字可以填。

因此再往后退一步，退到了状态：`3` _ _。第二个空位上除了填过的 `1`，`2`，没有其他数字可以填。

因此再往后退一步，退到了状态： _ _ _ 。第一个空位上除了填过的 `1`，`2`，`3`，没有其他数字可以填。

此时深度优先搜索结束，输出了所有的方案。


```c++
#include <iostream>
using namespace std;

int n, a[10];
bool st[10];

void dfs(int  u)
{
    if(u == n)
    {
        for(int i = 0;i < n; i++)
        {
            printf("%d ",a[i]);
        }
        puts("");
        return;
    }
    
    for(int i = 1; i <= n; i++)
    {
        if(!st[i])
        {
            a[u] = i;
            st[i] = true;
            dfs(u + 1);
            a[u] = 0; //恢复现场
            st[i] = false; //恢复现场
        }
    }
}
int main()
{
    scanf("%d",&n);
    
    dfs(0);
    
    return 0;
}
```

**2.n-皇后问题**

n−皇后问题是指将 `n` 个皇后放在 `n×n` 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数 `n`，请你输出所有的满足条件的棋子摆法。

方法一：
```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 10;
int n;
char g[N][N];//存路径
bool col[N],dg[N],udg[N];
//列数组，正对角线数组，反对角线数组，之所以使用布尔类型，可以判断出当前点是否访问。

void dfs(int u) //定x为u的状态，对y进行搜索
{
    if(u == n) //当所有都搜索完的时候，输出结果
    {
        for (int i = 0; i < n;i ++)   puts(g[i]);
        puts("");
        return ;
    }

    for (int i = 0;i < n; i ++)
    {
        if(!col[i] && !dg[u + i] && !udg[n - u + i])//防止反对角线出现负值+n
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);//递归下一层
            //恢复现场
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
    }
}

int main()
{
    cin >> n;

    for (int i = 0; i < n; i ++)
        for (int j = 0; j < n; j ++) 
            g[i][j] = '.';
            //初始化初状态

    dfs(0);

    return 0;
}
```
方法二：
```c++



#include <iostream>
using namespace std;

const int N =10;
int n;
char g[N][N];
bool row[N],col[N],dg[N * 2],udg[N * 2];

//此方法是枚举每个位置时候放皇后
void dfs(int x, int y, int s)//s判断放进皇后的数量
{
    if (s > n) return;
    if (y == n) y = 0,x ++;

    if(x == n)
    {
        if (s == n)
        {
        for (int i = 0; i < n; i ++)  puts(g[i]);
        puts("");
        }
    return ;
    }

    g[x][y] = '.';
    dfs(x, y + 1, s);

    if(!row[x] && !col[y] && !dg[x + y] && !udg[n + x - y])
    {
        row[x] = col[y] = dg[x + y] = udg[n + x - y] = true;
        g[x][y] = 'Q';
        dfs(x, y + 1, s + 1);
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[n + x - y] = false;
    }
}

int main()
{
    cin >> n;

    dfs(0, 0, 0);

    return 0;
}
```