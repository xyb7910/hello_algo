我们先来介绍一下[[BFS]]的基本概念🥰。

## 基本概念

BFS（广度优先搜索）是一种基础的图搜索算法，通常用于无权图的最短路径问题。BFS 从起点开始搜索，先访问起点，然后访问与起点直接相邻的所有节点，再访问与这些节点直接相邻的节点，依次类推，直到访问到终点或者遍历完整个图。BFS 保证了每个节点被访问的顺序是按照从起点到终点逐层递增的，因此搜索到终点时，所经过的路径一定是最短路径。

## 算法步骤：

- 初始化距离数组 $dist$，将起点的距离设为 $0$，其余节点的距离设为 $-1$。
- 将起点放入队列中。
- 当队列不为空时，取出队首节点 $t$。
- 遍历节点 $t$ 的相邻节点 $j$，如果 $j$ 未被访问过，则将 $j$ 的距离设为 $t$ 的距离 $+1$，并将 $j$ 放入队列中。
- 重复步骤 $3$ 至 $4$，直到队列为空或者找到终点。
- 返回终点的距离 $dist[n]$。


## 注意点
使用 BFS 求解最短路径问题时，需要注意以下几个问题：

1. 初始化距离数组：在 BFS 算法中，需要对距离数组进行初始化，将起点的距离设为0，其他节点的距离设为-1，表示这些节点还未被访问过。因此，在使用距离数组时，需要先进行初始化操作。

2. 存储节点相邻关系：在使用 BFS 算法时，需要存储节点之间的相邻关系，常用的数据结构是邻接表或邻接矩阵。其中，邻接表相对于邻接矩阵来说，更适合处理稀疏图的情况，因为邻接表可以动态地添加节点。

3. 遍历节点的相邻节点：在 BFS 算法中，需要遍历节点的相邻节点，如果某个相邻节点还未被访问，则将其加入队列中。在使用邻接表存储相邻关系时，需要使用指针数组或链表来存储每个节点的相邻节点。

4. 判断节点是否被访问过：在 BFS 算法中，需要判断节点是否已经被访问过，避免重复访问。常见的方法是使用布尔数组 $st$ 存储每个节点是否已经在队列中，如果已经在队列中，则不需要再次加入队列。

5. 选择起点和终点：在使用 BFS 算法求解最短路径问题时，需要选择起点和终点。通常情况下，起点和终点都是由输入数据给出的，但也有一些问题需要手动指定起点和终点。

## 时间复杂度

BFS 算法的**时间复杂度**为 $O(V+E)$，其中 $V$ 表示顶点数，$E$ 表示边数。因为每个节点最多被访问一次，每个边也最多被访问一次，所以时间复杂度是 $O(V+E)$。

## 使用场景

BFS 算法常用于解决无权图的最短路径问题，也可以用于解决其他图论问题，如连通性、路径计数等问题。此外，BFS 算法还可以用于搜索状态空间，求解迷宫等问题。

## 模板

以下给出BFS最短路径模板：

在 bfs 函数中，首先初始化距离数组为 -1，表示该点未被访问过。然后将起点 1 放入队列中，并将其距离设为0。然后开始 BFS 搜索，如果当前节点未被访问过，则将该节点的距离设为上一个节点的距离+1，并将该节点加入队列中。最后返回终点 n 的距离。

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int dist[N];  // 存储每个点到起点的距离
bool st[N];   // 存储每个点是否已经在队列中

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int bfs()
{
    memset(dist, -1, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] == -1)
            {
                dist[j] = dist[t] + 1;
                q.push(j);
            }
        }
    }

    return dist[n];
}

int main()
{
    cin >> n >> m;

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }

    cout << bfs() << endl;

    return 0;
}
```
其中，h 数组是邻接表的头指针数组，e 数组是邻接表的边，ne 数组是邻接表的边的指针，dist 数组是每个点到起点的距离，st 数组是每个点是否已经在队列中。

## 训练题

### 1.走迷宫

**Tag：朴素版BFS**

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1
，其中 0
 表示可以走的路，1
 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1)
 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m)
 处，至少需要移动多少次。

数据保证 (1,1)
 处和 (n,m)
 处的数字为 0
，且一定至少存在一条通路。

输入格式
第一行包含两个整数 n
 和 m
。

接下来 n
 行，每行包含 m
 个整数（0
 或 1
），表示完整的二维数组迷宫。

**输出格式**

输出一个整数，表示从左上角移动至右下角的最少移动次数。

**数据范围**

$1≤n,m≤100$

**输入样例**
```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```
**输出样例**
```
8
```

代码展示
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;
typedef pair<int, int> PII;
const int N = 110;
int n, m;
int dist[N][N], g[N][N];
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}; //四联通分量

int bfs()
{
    queue<PII> q;
    
    memset(dist, -1, sizeof dist);
    q.push({0, 0});
    dist[0][0] = 0;
    
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        
        for (int i = 0; i < 4; i ++)
        {
            int x = t.first + dx[i], y = t.second + dy[i];//表示下一步的位置
            if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && dist[x][y] == -1) //满足条件
            {
                dist[x][y] = dist[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }
    return dist[n - 1][m - 1]; //返回最后一个位置的距离
}

int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++)
            scanf("%d", &g[i][j]);
    cout << bfs() << endl;
    return 0;
}
```

### 2.迷宫问题

**Tag:朴素版 + 路径存储**

给定一个 n×n 的二维数组，如下所示：
```
int maze[5][5] = {

0, 1, 0, 0, 0,

0, 1, 0, 1, 0,

0, 0, 0, 0, 0,

0, 1, 1, 1, 0,

0, 0, 0, 1, 0,

};
```
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

数据保证至少存在一条从左上角走到右下角的路径。

**输入格式**

第一行包含整数 n。

接下来 n
 行，每行包含 n
 个整数 0 或 1，表示迷宫。

**输出格式**

输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。

按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)
，右下角坐标为 (n−1,n−1)
。

**数据范围**

$0≤n≤1000$

**输入样例**
```
5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```
**输出样例**
```
0 0
1 0
2 0
2 1
2 2
2 3
2 4
3 4
4 4
```

代码展示
```c++
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int g[N][N];
PII q[M];
PII pre[N][N];//表示先驱节点

void bfs(int sx, int sy)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};//定义四个联通分量

    int hh = 0, tt = 0; //手写队列
    q[0] = {sx, sy};

    memset(pre, -1, sizeof pre); //在每一次BFS我们都要对pre数组进行初始化
    pre[sx][sy] = {0, 0};
    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i]; //下一步的位置
            if (a < 0 || a >= n || b < 0 || b >= n) continue;//一般条件
            if (g[a][b]) continue; //本题目的特殊条件，0为路，1表示障碍物
            if (pre[a][b].x != -1) continue;

            q[ ++ tt] = {a, b};
            pre[a][b] = t;
        }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &g[i][j]);


    bfs(n - 1, n - 1); //倒着遍历

    PII end(0, 0); //对pair进行初始化

    while (true)
    {
        printf("%d %d\n", end.x, end.y);
        if (end.x == n - 1 && end.y == n - 1) break;
        end = pre[end.x][end.y]; //每次对先驱节点进行更新
    }

    return 0;
}
```

### 3.武士风度的牛🐮

**Tag：朴素版 + 路径优化**

农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。

这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。

虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x，y
 的坐标图来表示。

这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。

现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。

The Knight 的位置用 K 来标记，障碍的位置用 * 来标记，草的位置用 H 来标记。

这里有一个地图的例子：
```

             11 | . . . . . . . . . .
             10 | . . . . * . . . . . 
              9 | . . . . . . . . . . 
              8 | . . . * . * . . . . 
              7 | . . . . . . . * . . 
              6 | . . * . . * . . . H 
              5 | * . . . . . . . . . 
              4 | . . . * . . . * . . 
              3 | . K . . . . . . . . 
              2 | . . . * . . . . . * 
              1 | . . * . . . . * . . 
              0 ----------------------
                                    1 
                0 1 2 3 4 5 6 7 8 9 0 
```
The Knight 可以按照下图中的 A,B,C,D… 这条路径用 5 次跳到草的地方（有可能其它路线的长度也是 5
）：
```

             11 | . . . . . . . . . .
             10 | . . . . * . . . . .
              9 | . . . . . . . . . .
              8 | . . . * . * . . . .
              7 | . . . . . . . * . .
              6 | . . * . . * . . . F<
              5 | * . B . . . . . . .
              4 | . . . * C . . * E .
              3 | .>A . . . . D . . .
              2 | . . . * . . . . . *
              1 | . . * . . . . * . .
              0 ----------------------
                                    1
                0 1 2 3 4 5 6 7 8 9 0
```
注意： 数据保证一定有解。

**输入格式**

第 1 行： 两个数，表示农场的列数 C
 和行数 R
。

第 2..R+1 行: 每行一个由 C 个字符组成的字符串，共同描绘出牧场地图。

**输出格式**

一个整数，表示跳跃的最小次数。

**数据范围**

$1≤R,C≤150$

**输入样例**
```
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
```
**输出样例**
```
5
```

代码展示
```c++
#include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

const int N = 200, M = N * N;
typedef pair<int, int> PII;

int n, m;
char g[N][N];
int dist[N][N];
PII q[M];

int bfs(int sx, int sy)
{
    //定义牛所走方向的八联通方向
    int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

    memset(dist, -1, sizeof dist);
    dist[sx][sy] = 0;
    q[0] = {sx, sy};
    
    //手写队列
    int hh = 0, tt = 0;
    while(hh <= tt)
    {
        PII t = q[hh ++];
        
        for (int i = 0; i < 8; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            
            if(a < 0 || a >= n || b < 0 || b >= m) continue;//一般出界条件
            if(dist[a][b] != -1 || g[a][b] == '*') continue;//表示这个点没有遍历过，且不为阻碍物
            if(g[a][b] == 'H') return dist[t.x][t.y] + 1;//BFS结束条件
            
            dist[a][b] = dist[t.x][t.y] + 1;//对距离进行更新
            q[++ tt] = {a, b};//将新元素入队
            
        }
    }
    return -1;//因为题目一定有解，所以返回值可以忽略不写，但考虑到程序的严谨性，我们还是写上
}

int main()
{
    scanf("%d%d", &m, &n);
    
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);
    
    int sx = 0, sy = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if(g[i][j] == 'K') //寻找出牛的位置，我们从牛的位置开始遍历
            {
                sx = i;
                sy = j;
            }
    cout << bfs(sx, sy) << endl;
    
    return 0;
}
```

## 总结

我们不难发现使用BFS求解最短路问题的时候，无非还是使用队列去实现。

只不过在不同的问题上，可能对与以下一步的位置进行了限制，就如，我们这次的第三题，每次牛只能走”日“字。

还是像之前强调的一样，我们在对下一步进行遍历的时候一定要注意下一步的条件！！！ 做到先考虑一般条件后考虑本题目的特殊条件。

最后，这个算法其实并不难，但是需要我们静下心来去细细斟酌条件，
如果要把编程分为思维能力和码代码能力，我想对于BFS求解最短模型，要的码代码能力远远高于思维😅。
