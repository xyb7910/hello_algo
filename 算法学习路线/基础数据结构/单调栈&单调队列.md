
## 单调栈
在这之前我们都知道什么是栈了，它具有先入后出的性质。从名字上就听的出来，单调栈中存放的数据应该是严格单调有序的。<br>
**单调栈的性质：**

- 满足从栈顶到栈底的元素具有严格的单调递增或单调递减性；
- 满足栈的后进先出特性，即越靠近栈底的元素越早进栈。<br>

**单调栈的分类：**
- 单调递增栈：从栈底到栈顶数据是从小到大
- 单调递减栈：从栈底到栈顶数据是从大到小

看完了单调栈的定义以及性质，我们来想想怎么维护一个单调栈呢？与普通的栈类似，无非是进栈。

**进栈的步骤**
- 对于单调递增栈，若当前进栈元素为`e`，从栈顶开始遍历元素，把小于`e`或者等于`e`的元素弹出栈，直接遇到一个大于`e`的元素或者栈为空为止，然后再把`e`压入栈中。<br>
- 对于单调递减栈，则每次弹出的是大于`e`或者等于`e`的元素。<br>
对于一个元素`a`，如果栈空则直接入栈。否则比较`a`与栈顶元素。

<font color = " #70DB93">看苦涩的文字是很难看懂的，举个单调递增栈的栗子吧。</font><br>
  进栈元素分别为3，4，2，6，4，5，2，3<br>
 始终记住，弹出栈的元素$\leq$当前入栈元素

|第i步|	操作|	结果|
|:----| :---:| ---:|
|1	|3进栈|	3|
|2	|3出栈，4进栈|	4|
|3	|2进栈|	4 2|
|4	|2、4出栈，6进栈|	6|
|5	|4进栈	|6 4|
|6	|4出栈，5进栈|	6 5|
|7	|2进栈|	6 5 2|
|8	|2出栈，3进栈|	6 5 3|
  
看完了单调栈的基本概念，接下来看看单调栈的应用吧。<br>
**应用**<br>
- 左边区间第一个比它小的数，第一个比它大的数
- 确定这个元素是否是区间最值
- 右边区间第一个大于它的值
- 到右边区间第一个大于它的值 的距离
- 确定以该元素为最值的最长区间
  

**单调栈模板**
```c++
 // 常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
                      
**例题**<br>
  Acwing830. 单调栈<br>
  给定一个长度为` N `的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出` −1`。
```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int N=1e5+10;
int tt,stk[N];

int main()
{
    int n;
    scanf("%d",&n);
    
    for(int i=0;i<n;i++)
    {
        int x;
        scanf("%d",&x);
        
        while(tt && stk[tt] >= x)  tt--;
        if(!tt)  printf("-1");
        else printf("%d ",stk[tt]);
        
        stk[++ tt]=x;
    }
    
    return 0;
}
  ```
## 单调队列
基于单调栈的一个扩展，当单调栈的栈底元素可以弹出的时候，单调栈即可转化单调队列。单调队列是一个受限的双端队列，因为队头只能弹出元素。由单调栈可以知道，单调栈维护的是单调区间。
  
 以上面的单调递增栈为例子，栈底的元素，永远是当前区间中最大的值，因此单调队列可以在`O(1)`的时间内，获取队首队尾区间的最值，因此单调队列的最大用处，也在于获取区间的最值上。
  
对于单调队列，从单调栈的性质我们可以类推出：
- 从队列头到队列尾的元素是严格递增/递减
  
**单调队列的入队过程**
- 对于单调递增队列，设当前准备入队的元素为`e`，从队尾开始把队列中的元素逐个与`e`对比，把比`e`大或者与`e`相等的元素逐个删除，直到遇到一个比`e`小的元素或者队列为空为止，然后把当前元素`e`插入到队尾。
- 对于单调递减队列也是同样道理，只不过从队尾删除的是比`e`小或者与`e`相等的元素。

<font color = " #70DB93">&ensp;&ensp;&ensp;&ensp;同样的，咱们举个单调递增队列的栗子，便于记忆。</font><br>队列大小不能超过3，入队元素依次为3，2，8，4，5，7，6，4<br>
  <font color = "red">始终记住，我们每次弹出的元素 `>=` 当前入队元素</font>

|第i步|	操作|	结果|
| :--- | :---: | :--- |
|1	|3入队	|3|
|2	|3从队尾出队，2入队	|2|
|3|	8入队|	2 8|
|4|	8从队尾出队，4入队|	2 4|
|5	|5入队|	2 4 5|
|6	|2从队头出队，7入队	|4 5 7|
|7|	7从队尾出队，6入队	|4 5 6|
|8	|6、5、4从队尾出队，4入队|	4|

**应用**
- 可以查询区间最值
- 优化DP
  
**单调队列模板**
```c++
  //常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
  
**例题**
  
Acwing154. 滑动窗口<br>
  给定一个大小为 $\ce{n<=10^6}$的数组。

有一个大小为 `k `的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到` k` 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，`k` 为 `3`。

| 窗口位置                | 最小值 | 最大值 |
| :------------------ | :-: | :-- |
| [1 3 -1] -3 5 3 6 7 | -1  | 3   |
| 1 [3 -1 -3] 5 3 6 7 | -3  | 3   |
| 1 3 [-1 -3 5] 3 6 7 | -3  | 5   |
| 1 3 -1 [-3 5 3] 6 7 | -3  | 5   |
| 1 3 -1 -3 [5 3 6] 7 |  3  | 6   |
| 1 3 -1 -3 5 [3 6 7] |  3  | 7   |
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int N=1e6+10;
int a[N],q[N];
int n,k;

int main()
{
    cin>>n>>k;
    for(int i=0;i<n;i++)  cin>>a[i];
    
    int hh=0,tt=-1;
    for(int i=0;i<n;i++)
    {
        //调整队列
        if( hh<=tt && i-k+1 > q[hh])  hh++;//队头--队列不为空并且用窗口对队列长度进行限制
        while(hh <= tt && a[q[tt]]>=a[i])  tt--;//队尾--此队列永远维护最小值
        q[++ tt] =i;//队列储存下标
        
        if(i>=k-1)//把队列输出
        printf("%d ",a[q[hh]]);
    }
    
    puts(" ");
    
    hh=0,tt=-1;
    for(int i=0;i<n;i++)
    {
        //调整队列
        if( hh<=tt && i-k+1 > q[hh])  hh++;//队头--队列不为空并且用窗口对队列长度进行限制
        while(hh <= tt && a[q[tt]]<=a[i])  tt--;//队尾--此队列永远维护最大值
        q[++ tt] =i;//队列储存下标
        
        if(i>=k-1)//把队列输出
        printf("%d ",a[q[hh]]);
    }
    
    puts(" ");
    
    return 0;
}
 ```
## 单调栈与单调队列的异同
**相同点**
1. 单调队列和单调栈的“头部”都是最先添加的元素，“尾部”都是最后添加的元素。
2. 递增和递减的判断依据相同：从栈底（队尾）到栈顶（队首），元素大小的变化情况。所以队列和栈是相反的。
3. 两者维护的时间复杂度都是`O(n`)，每个元素都只操作一次。
  
**不同点**
1. 单调队列可以从队列头弹出元素，可以方便地根据入队的时间顺序（访问的顺序）删除元素。
2. 单调队列和单调栈维护的区间不同。当访问到第i个元素时，单调栈维护的区间为`[0,i)`，而单调队列维护的区间为`(L,R)`.
3. 单调栈无法获取`[0,i)`的区间最大值/最小值。单调队列可以访问“头部”和“尾部”，而单调栈只能访问栈顶（也就是“尾部”）。
## 快速解题

 对于左右端点都发生变化的问题，我们就可以使用单调队列进行维持，不过值得注意的是，类似于队列的描述，只有区间变化满足类似于队列的元素流动的方向时，我们才可以使用单调队列求解，这是为什么呢？
  
 前面我们已经说过，单调栈因为左端点，不变，所以可以支持一个端点左移或者右移的操作，而之所以可以左移或者右移，是因为单调栈只插入满足条件的点，而不会对以及入栈的元素进行最优性剪枝，这样，就保证了右端点可以左移的条件；而单调队列在维持的过程中，整个要维持的区间是单向移动的，假设要维持的两个端点都是向右移动的，那么当左端点右移时，实际上最次最优值是会发生变化的，这样为了保证左端点右移时候选最优值的正确性，我们在右端点右移的过程中，必须把当前元素插入到单调队列中（单调栈则不用），这样插入时，为了维持单调性，我们就需要进行最优性剪枝，此时如果我们再将右端点左移，那么上一回合插入的元素实际上需要删除，但是上一回合中我们已经进行了最优性剪枝，这样即使我们将上一回合插入的元素删除，我们也不能将单调队列在恢复到之前的状态。
  
 综上，我们得到使用单调队列的问题，要维持的区间一定是左右端点同时单向移动的；而使用单点栈的问题，则一定是只有一个端点左移或者右移的。
 
  根据以上两个特征我们可以很轻松地判断一个问题到底是应该使用那个结构来维持，当然不过单调栈还是单调队列，我们都可以用双端队列维持，这是因为双端队列可以满足单调栈或者单调队列的所有要求。
  
  最后，使用单调栈的问题，我们一定使用的是双端队列维持，有一个端点需要同时插入和删除，所以队列是不满足要求的。
  
> 引荐博客：
  https://blog.csdn.net/Sky_River_Z/article/details/113792742
  https://blog.csdn.net/qq_37957064/article/details/115939792
  https://blog.csdn.net/qq_35976351/article/details/103691657