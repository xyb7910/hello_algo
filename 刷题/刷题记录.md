# 学痕如墨，思辙成蹊

古人论学，常以 “雁过留痕” 为喻。那些在典籍中沉淀千年的箴言，恰似暗夜中的星斗，指引着求学者的路径 ——“学习必须留痕迹，做题必须有记录，要善于总结，善于发现问题”。这短短数语，道尽了治学的根本法门，既是对知识积累的敬畏，更是对思维成长的深刻洞察。在编程学习与算法竞技的世界里，这份智慧愈发闪耀出精准的光芒。

学习留痕，是与知识对话的凭证。当我们在书页间批注感悟，在笔记里梳理脉络，那些墨迹与符号便成了思想交锋的痕迹。于编程学习者而言，这痕迹是代码行间的注释，是调试时写下的思路草稿，是框架图上标注的逻辑节点。就像考古学家从陶片的纹路中还原文明，开发者也能从注释完备的代码里重拾当时的设计考量。开源社区里流传的经典项目，往往以详尽的注释文档著称 —— 那些穿插在函数间的文字，既是与未来自己的对话，也是与同行者的思想共鸣。朱熹读书时 “每书必通校数过，注字不厌重复”，如今的程序员在重构代码时反复修订注释，正是以同样的严谨，在数字世界里搭建起可追溯的思维桥梁。

做题记录，是叩问真理的阶梯。演算纸上的潦草公式，错题本里的红笔批注，看似是枯燥的重复，实则是与错误的正面交锋。在算法学习的疆域中，这份记录显得尤为珍贵。信奥赛选手的训练日志里，整齐排列着不同难度的算法题解，从动态规划的状态转移方程到图论模型的构建思路，每一页都浸透着推敲的汗水。ICPC 赛场上，选手们在草稿纸上快速推演的算法草图，赛后录入团队知识库的错题分析，恰如数学家陈景润装满麻袋的草稿纸 —— 那些被反复涂改的伪代码，正是逼近最优解的脚印。当一道算法题在多次提交后终于通过，判题系统显示的 “Accepted” 背后，是错题本里对边界条件的反复标注，是对时间复杂度优化的层层拆解。

总结与发现，是治学的灵魂所在。如果说记录是散落的珍珠，总结便是穿珠的丝线。编程世界里，这种丝线体现为对算法模板的归纳，对代码架构的提炼。信奥赛教练常要求学生整理 “算法谱系”，将同类问题的解法归门别类，如同中药铺里按药性排列的药柜；ICPC 团队赛后的复盘会，总要将赛题按知识点归档，分析解题策略的优劣。这种总结，让孤立的算法题升华为可复用的思维模型，正如战国墨子在实践中总结出 “墨经” 中的光学原理。而发现问题，在算法竞技中更显关键 —— 当一段代码始终超时，或许正是发现数据结构缺陷的契机；当某类题目反复出错，往往意味着对算法本质的理解尚有盲区。就像爱因斯坦所言，提出问题比解决问题更重要，ICPC 赛场上，那些能敏锐发现题目隐藏条件的团队，往往能抢占解题先机。

回望编程领域的探索者，无不是 “留痕、记录、总结、发现” 的践行者。Linux 内核的开发者们，以详尽的提交日志记录着每一次迭代，在千万行代码中留下可追溯的演进轨迹；图灵奖得主高德纳在撰写《计算机程序设计艺术》时，对每一个算法的反复推演与注释，成为后世开发者的思维指南。他们的成就，从来不是灵光乍现的编程灵感，而是在键盘敲击的痕迹中，在代码调试的记录里，经由持续总结与问题发现，最终凝结成推动技术进步的基石。

如今的数字时代，屏幕上的代码替代了竹简上的墨迹，在线判题系统的提交记录替代了演算纸的划痕，但治学的真谛从未改变。当我们在 Git 仓库里提交带有注释的代码，在 LeetCode 上整理错题集，在团队知识库中更新算法总结，便是在践行古人的教诲。真正的编程学习，从来不是机械地复制代码，而是主动建构思维的逻辑 —— 用注释锚定思路，用提交记录校准方向，用算法总结搭建体系，用问题发现开拓边界。

学痕如墨，晕染出认知的疆域；思辙成蹊，铺就通往真理的路径。愿每一位编程学习者与赛事参与者，都能以敬畏之心对待每一行注释，以敏锐之眼捕捉每一处漏洞，在代码与算法的世界里，既留下扎实的数字足迹，更收获思维成长的丰盈。

# 背包问题

# P1802 5 倍经验日

题目链接：https://www.luogu.com.cn/problem/P1802

01背包的变形：药物 ==> 背包容量 朋友 ==> 物品（包含失败经验和成功经验）

朴素解法(二维)

```C++
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 1e3 + 10;
int n, m;
int win[N], lose[N], use[N];
ll f[N][N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d%d", &lose[i], &win[i], &use[i]);
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j <= m; j ++)
        {   
            f[i][j] = f[i - 1][j] + lose[i]; // 打不过第i个人if(j >= use[i]) // 打的过第i个人
            if(j >= use[i]) f[i][j] = max(f[i - 1][j] + lose[i], f[i - 1][j - use[i]] + win[i]);               
        }   
    printf("%lld", f[n][m] * 5);
    return 0;
}
```

一维优化解法

```C++
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 1e3 + 10;
int n, m;
int win[N], lose[N], use[N];
ll f[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d%d", &lose[i], &win[i], &use[i]);
    for (int i = 1; i <= n; i ++)
        for (int j = m; j >= use[i]; j --)
        {   
            f[j] = max(f[j] + lose[i], f[j - use[i]] + win[i]);               
        }   
    printf("%lld", f[m] * 5);
    return 0;
}
```

# P1164 小A点菜

题目链接：https://www.luogu.com.cn/problem/P1164

01背包求方案数: 与原本的01背包不同，计数问题的转移方程应该为"累加" ，而非"求最大值"。

正确的转移逻辑:

- 对于第i道菜，有两种选择
    
    - 不选：方案数 = 前 i - 1 道菜构成的 j 元的方案数 f[i - 1][j]；
        
    - 选择(j >= v[i]): 方案数 += 前 i - 1 道菜构成的 j - v[i] 元的方案数 f[i - 1][j - v[i]]；
        

故此，可得转移方程为 f[i][j] = f[i - 1][j] + (j >= v[i] ? f[i - 1][j - v[i]] : 0)

```C++
#include <iostream>
using namespace std;
const int N = 1e4 + 10;
typedef long long ll;
int n, m, v[N];
ll f[N][N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &v[i]);
    f[0][0] = 1;
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j <= m; j ++)
        {
            f[i][j] = f[i - 1][j] + (j >= v[i] ? f[i - 1][j - v[i]] : 0);
        } 
    printf("%lld", f[n][m]);
    return 0;
}
```

# U517864 分组背包

  

朴素版：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 210;
struct Item {
    int v, w;
};
vector<Item> g[N];
int f[N][N];
int main() {
    int m, n, t; scanf("%d%d%d", &m, &n, &t);
    for (int i = 0; i < n; i ++)
    {
        int w, c, p; scanf("%d%d%d", &w, &c, &p);
        g[p].push_back({w, c});
    }
    for (int i = 1; i <= t; i ++)
        for (int j = 0; j <= m; j ++)
        {
            f[i][j] = f[i - 1][j];
            for (int k = 0; k < g[i].size(); k ++)
                if(j >= g[i][k].v) f[i][j] = max(f[i][j], f[i - 1][j - g[i][k].v] + g[i][k].w);
        }
    printf("%d", f[t][m]);
    return 0;
}
```

一维优化版：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 210;
struct Item {
    int v, w;
};
vector<Item> g[N];
int f[N];
int main() {
    int m, n, t; scanf("%d%d%d", &m, &n, &t);
    for (int i = 0; i < n; i ++)
    {
        int w, c, p; scanf("%d%d%d", &w, &c, &p);
        g[p].push_back({w, c});
    }
    for (int i = 1; i <= t; i ++)
        for (int j = m; j >= 0; j --)
        {
            for (int k = 0; k < g[i].size(); k ++)
                if(j >= g[i][k].v) f[j] = max(f[j], f[j - g[i][k].v] + g[i][k].w);
        }
    printf("%d", f[m]);
    return 0;
}
```

# 开心的金明

01背包问题：

![](https://wrpnn3mat2.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUwYjExZDFlY2ViNGVmNWNmZGYxNDUyODEyYjQwMTBfV2Q2YWQyZ1hLVmhIZHk3Z3NEN3pFUmpZcEZSNDNxcUVfVG9rZW46RDJZNGJpQVlBb3diQ2d4Z21yemNlNzVzbjdWXzE3NTM2ODcwNTI6MTc1MzY5MDY1Ml9WNA)

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 10, M = 30;
int n, m;
int v[M], p[M], f[N];
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i ++)
        scanf("%d%d", &v[i], &p[i]);
    for (int i = 1; i <= m; i ++)
            for (int j = n; j >= v[i]; j --)
            {
                f[j] = max(f[j], f[j - v[i]] + v[i] * p[i]);
            }
    printf("%d", f[n]);    
    return 0;
}
```

# 二维费用背包

朴素版

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m, l;
int f[N][110][110], v[N], e[N], w[N];
int main() {
    scanf("%d%d%d", &n, &m, &l);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d%d", &v[i], &e[i], &w[i]);
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j <= m; j ++)
            for (int k = 0; k <= l; k ++)
            {
                f[i][j][k] = f[i - 1][j][k];
                if(j >= v[i] && k >= e[i])
                    f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - v[i]][k - e[i]] + w[i]);
            }
    printf("%d", f[n][m][l]);
    return 0;
}
```

二维优化

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m, l;
int f[110][110], v[N], e[N], w[N];
int main() {
    scanf("%d%d%d", &n, &m, &l);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d%d", &v[i], &e[i], &w[i]);
    for (int i = 1; i <= n; i ++)
        for (int j = m; j >= v[i]; j --)
            for (int k = l; k >= e[i]; k --)
            {
                f[j][k] = max(f[j][k], f[j - v[i]][k - e[i]] + w[i]);
            }
    printf("%d", f[m][l]);
    return 0;
}
```

# 序列问题

# 最长上升子序列

定义： f[i] 为以 num[i] 为结尾的最长上升子序列的长度

步骤：

1. 对于每一个 num[i] ，要找前面比它小的元素 num[j] (j < i);
    
    1. 如果 num[j] < num[i], 则以 nums[j] 结尾的子序列后拼接 num[i]，长度为 f[j] + 1;
        
    2. 遍历所有符合条件的 j，取最大的 f[j] + 1 作为当前f[i] 的值（没有符合条件的 j,f[i]保持初始值1）。
        

转移方程为：

$$f[i] = \max\left\{ f[j] + 1 \mid 0 \leq j < i \ \text{且} \ \text{nums}[j] < \text{nums}[i] \right\} $$

```C++
#include <bits/stdc++.h>using namespace std;
const int N = 5010;
int n, a[N], f[N], ans;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++)
            if(a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
        ans = max(ans, f[i]);
    }
    cout << ans;
    return 0;
}
```

# 合唱队形

本题要求对数组删去尽量少的数字，构成一个 “合唱队形”数列；

（对于一个子序列，就是通过删去原序列中部分元素后构成的。）

因此，找到满足“合唱队形”的数列，最少需要删除的元素数量等价为

原序列中元素个数 - max(最长上升子序列长度 + 最长下降组序列长度 - 1);

![](https://wrpnn3mat2.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg1ZTg0OTdiNjA0MTBiOThmZGVhNjZlNGM4MTQ2YmZfYzhVVXZrUU9xSkltejREb1FDd3pzUDk4UmVMcFBvc0tfVG9rZW46RXVQbWI3S2NybzZMYXB4NFBJcmM0TjFsbkpoXzE3NTM2ODcwNTI6MTc1MzY5MDY1Ml9WNA)

```C++
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 110;
int n, a[N], f[N], g[N], res;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++)
            if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    }
    for (int i = n; i >= 1; i --)
    {
        g[i] = 1;
        for (int j = n + 1; j > i; j --)
            if(a[i] > a[j]) g[i] = max(g[i], g[j] + 1);
    }
    for (int i = 1; i <= n; i ++)
        res = max(res, f[i] + g[i] - 1);
    printf("%d", n - res);
    return 0;
}
```

# 数的计算

定义： f[i] 表示以当前数字 i 为结尾的符合条件的序列长度。

```C++
#include <iostream>
#include <cstdio>
const int N = 1e3 + 10;
int n, f[N];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for (int j = 1; j <= i / 2; j ++)
            f[i] += f[j];
    }
    printf("%d", f[n]);
    return 0;
}
```

# 数字三角形

从上往下走，注意输入从1开始的话，可以避免掉对于边界的处理。

额外注意：本题的数据范围包含负数，所以必须让 `f` 数组初始化为负无穷。

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 510, INF = -0x3f3f3f3f;
int a[N][N], f[N][N], n, ans = INF;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++)
            scanf("%d", &a[i][j]);
    memset(f, INF, sizeof f);
    f[1][1] = a[1][1];
    for (int i = 2; i <= n; i ++)
        for (int j = 1; j <= i; j ++)
            f[i][j] = max(f[i - 1][j], f[i - 1][j - 1]) + a[i][j];
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[n][i]);
    printf("%d", ans);
    return 0;
}
```

倒着来做的话，访问的元素都在三角形内，所以不用处理边界，也不用将`f`数组初始化为负无穷。

```Plain
#include <bits/stdc++.h>
using namespace std;
const int N = 510;
int a[N][N], f[N][N], n;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++)
            scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i ++) f[n][i] = a[n][i];
    for (int i = n - 1; i >= 1; i --)
        for (int j = i; j >= 1; j --)
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];
    printf("%d", f[1][1]);
    return 0;
}
```

# 纸币问题 1

完全背包问题，只不过需要求最小值，那么在求之前，一定要将数组内的每一个值初始化为**极大值**。

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10;
int n, m, f[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i ++ ) f[i] = N;
    for (int i = 1; i <= n; i ++) {
        int v; scanf("%d", &v);
        for (int j = v; j <= m; j ++)
            f[j] = min(f[j], f[j - v] + 1);
    }
    printf("%d", f[m]);
    return 0;
}
```

# 最大子段和

定义: f[i] 表示以当前第 i 个数字为结尾的最大字段和

那么，第i个位置就有两种情况：

- 选择第i个位置：f[i] = f[i - 1] + a[i];
    
- 不选择第i个位置：f[i] = a[i];
    

综上，f[i] = max(f[i - 1] + a[i], a[i])。（要么从上一段拼接过来，要么另起新的一段）

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, INF = -0x3f3f3f3f;
int n, a[N], f[N], res = INF;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
    {
        scanf("%d", &a[i]);
        f[i] = max(f[i - 1] + a[i], a[i]);
        res = max(res, f[i]);
    }
    printf("%d", res);
    return 0;
}
```

# 最小子段和

思路：对数组全部取负，然后跑最大子段和，然后对res取负

```C++
int res = -1e18; //注意这里求最小赋值的是负的最小  
for(int i = 1; i <= n; i ++ )
{
    cin >> a[i];
    dp[i] = max(dp[i - 1] - a[i], -a[i]);
    res = max(res, dp[i]);
}
res = - res;
```

# 友好城市

规定一岸为**自变量**，排完序之后求**因变量**的 LIS 就可以。(斜率一致性的最大数量)

朴素版时间复杂度为 O(N).

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
typedef pair<int, int> PII;
PII a[N];
int n, f[N], res;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        scanf("%d%d", &a[i].first, &a[i].second);
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++)
            if(a[j].second < a[i].second)
                f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
    }
    printf("%d", res);
    return 0;
}
```

使用二分进行优化，时间复杂度为O(nlogn).

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
typedef pair<int, int> PII;
PII a[N];
int q[N];

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d", &a[i].first, &a[i].second);
    sort(a + 1, a + 1 + n);
    int len = 0;
    q[0] = -1;
    for (int i = 1; i <= n; i ++)
    {
        int l = 0, r = len;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(q[mid] < a[i].second) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i].second;
    }
    printf("%d", len);
    return 0;
}
```

# 围栏木桩

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 30;
int t, n, a[N], f[N], g[N];
int main() {
    scanf("%d", &t);
    while(t --)
    {
        memset(a, 0, sizeof a);
        memset(f, 0, sizeof f);
        memset(g, 0, sizeof g);
        scanf("%d", &n);
        for (int i = 1; i <= n; i ++)
            scanf("%d", &a[i]);
        int res = 0, ans = 0;
        for (int i = 1; i <= n; i ++)
        {
            f[i] = 1, g[i] = 1;
             for (int j = 1; j < i; j ++)
                if(a[j] <= a[i])
                {
                    if(f[j] + 1 > f[i])
                    {
                        f[i] = f[j] + 1;
                        g[i] = g[j];
                    }
                    else if(f[j] + 1 == f[i])
                    {
                        g[i] += g[j];
                    }
                }
            if(res < f[i])
            {
                res = f[i];
                ans = g[i];
            }
        }   
        printf("%d %d\n", res, ans);
    }
    return 0;
}
```

# 导弹拦截

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4 + 10;
int d, a[N], q[N], f[N];
int main() {
    while(cin >> a[++ d]);
    int len = 0, cnt = 0;
    q[0] = N;
    for (int i = 1; i < d; i ++) {
        int l = 0, r = len;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(q[mid] > a[i]) l = mid;
            else r = mid - 1; 
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
        
        int k = 0;
        while(k < cnt && f[k] < a[i]) k ++;
        if(k == cnt) f[cnt ++] = a[i];
        else f[k] = a[i];
    }   
    printf("%d\n%d", len, cnt);
    return 0;
}
```

# P1439 【模板】最长公共子序列

# P1077 摆花

多重背包求方案数

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, MOD = 1000007;
int n, m, a[N], f[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    f[0] = 1;
    for (int i = 1; i <= n; i ++)
        for (int j = m; j >= 0; j --)
        {
            for (int k = 1; k <= a[i] && k <= j; k ++)
                f[j] = (f[j] + f[j - k]) % MOD;
        }
    printf("%d", f[m]);
    return 0;
}
```

# 双指针

Leetcode 15.[三数之和](https://leetcode.cn/problems/3sum/)

先对数据进行排序

枚举变量 i ，然后使用对撞指针的思想去判断 指针 j 和指针 k 的合适位置。

需要注意的是，如果发现数据是相同的，那么找到的数据组集合也是一样的。

时间复杂度为 O(n)。

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i ++)
        {
            if(i && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1, k = nums.size() - 1; j < k; j ++)
            {
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;
                while(j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= 0) k --;
                if(nums[i] + nums[j] + nums[k] == 0)
                    res.push_back({nums[i], nums[j], nums[k]});
            }
        }
        return res;
    }
};
```

Leetcode 11.[盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

使用两个指针 $i$, $j$ 分别指向数组的首部和尾部，每次只移动较小的指针即可。
如果 $a_i$ < $a_j$ ，则 $i ++$；否则 $j --$；直到 $i == j$，每次迭代更新一下最大值即可。
时间复杂度为 $O(n)$。

```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size() - 1, ans = 0;
        for (int i = 0, j = n; i < j; )
        {
            ans = max(
                ans, min(height[i], height[j]) * (j - i)
            );
            if(height[i] > height[j]) j --;
            else i ++;
        }
        return ans;
    }
};
```

Luogu [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)

Leetcode 3.[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
快慢指针：
可以使用两个变量 $i$ 表示快指针，$j$ 表示慢指针。
使用 `unordered_map` 来存储每个字符出现的次数，如果当前字符 `s[i]` 没有出现过，那么让出现的次数 `+ 1`；否则让其出现的次数`- 1`,指针变量 `j` 往后移动。每次更新的时候，求长度的最大值即可。
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size(), ans = 0;
        unordered_map<int, int> heap;
        for (int i = 0, j = 0; i < n; i ++)
        {
            heap[s[i]] ++;
            while(heap[s[i]] > 1) heap[s[j ++]] --;
            ans = max(ans, i - j + 1);
        }
        return ans;
    }
};
```

ABC302D：[AT_abc302_d [ABC302D] Impartial Gift](https://www.luogu.com.cn/problem/AT_abc302_d)