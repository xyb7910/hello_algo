# [九月月考-T1] 数组与内存 HV

## 题目描述

一维数组常常被想象为一个线性的数列，二维数组常常被想象为一个平面上的矩阵，三维数组常常被想象为空间中的一个立方体。由于我们生存在三维宇宙中，再高维度的数组的形态难以被想象，但是我们有理由认为，$n$ 维数组在 $n$ 维空间中可以被想象为一个几何体。

但是，无论数组的维数多高，计算机的内存空间总是线性的。
- C++ 在定义一维数组 $a[N]$ 时，会从 $a[0]$ 开始，在内存中连续申请 $N$ 个变量的**连续的**空间，依次分配给 $a[0],a[1],\cdots,a[N-1]$。

- 二维数组 $a[N][M]$ 可以看作 $N$ 个大小为 $M$ 的一维数组连续拼接在一起。C++ 在定义二维数组 $a[N][M]$ 时，会从 $a[0][0]$ 开始，在内存中申请 $N\times M$ 个变量的**连续的**空间，先排布 $a[0]$ 的一维数组，再依次排布 $a[1],a[2],\cdots,a[N-1]$ 的一维数组。排布规则与上面一维数组的情形相同。

- 三维数组 $a[N][M][K]$ 可以看作 $N$ 个大小为 $M\times K$ 的二维数组连续拼接在一起，这些大小为 $M\times K$ 的二维数组，又可以分别看作 $M$ 个大小为 $K$ 的一维数组连续拼接在一起。C++ 在定义三维数组 $a[N][M][K]$ 时，会从 $a[0][0][0]$ 开始，在内存中申请 $N\times M\times K$ 个变量的**连续的**空间，先排布 $a[0]$ 的二维数组，再依次排布 $a[1],a[2],\cdots,a[N-1]$ 的二维数组。排布规则与上面二维数组的情形相同。

- 更高维的数组以此类推。

众所周知，二维数组 $a[N][M]$ 可以使用的下标范围为 $a[0\sim N-1][0\sim M-1]$。但是，当定义了数组 $a[2][3]$，并使用了下标 $a[0][4]$，并不会访问非法内存，而是会访问到 $a[1][1]$。这是因为数组是依托于**连续线性**内存的，$a[0][4]$ 与 $a[1][1]$ 都是指向自 $a[0][0]$ 数起的（含 $a[0][0]$）第 $5$ 个变量，它们指向的内存地址是相同的。更高维度的数组亦有相同的机制。

虽然这样的写法不会导致运行时错误，但是它是不规范的。我们称使用的下标的数值，小于对应维度定义大小的访问方法是**规范的**。例如，对于数组 $a[2][3]$，$a[0][4]$ 是不规范的，而 $a[1][1]$ 是规范的。

现在，小 F 定义了一个 $n$ 维数组 $a[K_1][K_2]\cdots[K_n]$，并尝试访问 $a[p_1][p_2]\cdots[p_n]$，请你给出这个位置规范化的表达方式，或报告访问非法内存。

## 输入格式

输入共三行。

输入的第一行为一个整数 $n$。

输入的第二行为 $n$ 个整数，第 $i$ 个为 $K_i$。

输入的第三行为 $n$ 个整数，第 $i$ 个为 $p_i$。

## 输出格式

输出一行 $n$ 个整数，由空格隔开，表示规范化的下标。

如果会访问非法内存，输出 `Segmentation Fault`。

## 样例 #1

### 样例输入 #1

```
2
2 3
0 4
```

### 样例输出 #1

```
1 1
```

## 样例 #2

### 样例输入 #2

```
2
2 3
1 4
```

### 样例输出 #2

```
Segmentation Fault
```

## 提示

- 对于 $15\%$ 的测试数据，$n = 1$；
- 对于另外 $15\%$ 的测试数据，$n=2$；
- 对于 $70\%$ 的测试数据，$n \le 9$；
- 对于 $100\%$ 的测试数据，$1 \le n \le 14$，$1 \le K_i \le 10$，$0 \le p_i \le 20$。