# C++引用
引用变量是一个**别名**，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

对引用的操作与对变量直接操作完全一样。

> 格式为：类型 &引用变量名 = 已定义过的变量名。

## 引用的特点
1. 一个变量可以有多个别名。
2. 引用必须初始化。

## 引用与指针
不同点
- 指针是一个实体，而引用仅是个别名。
- 引用使用时无需解引用，指针需要解引用。
- `sizeof 引用`得到的是所指向的变量(对象)的大小，而`sizeof 指针`得到的是指针本身(所指向的变量或对象的地址)的大小；
- 不存在空的引用，引用必须与一个合法的内存块连接。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。
- 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

相同点

- 两者都是地址的概念，指针指向一块儿内存，其内容为所指内存的地址；引用是某块儿内存的别名。

## 巧记引用

我们可以把变量名称是变量附属在内存位置中的标签，你可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。
```c++
#include <iostream>
using namespace std;

int main()
{
	int i = 4;
	int &p = i;
	
	cout << i << endl;
	cout << p << endl;
	return 0;
}
```
输出结果
```
4 //第一个为i获取的值
4 //第二个为通过引用p获取的值
```
## 引用的用处

### const式引用
```c++
 int i = 4;
	const int &p = i; //对普通整型的引用
	i = 5; //当i的值发生变化时，引用变量p的值也会随之改变
	//此时i的值为5，p的值为5； 
	 
	const int j = 3;
	const int &q = j;//对常量整型的引用
	//对常量的引用只能用常量来引用，如果我们删去q之前的const会编译错误 
	//并且常量具有不能修改的特性
	
	double k = 1.3;
	const int &l = k; 
	//变量的类型可以不同但之间会加以强制转化 
	int a = 5;
	const double &s = a; 
```

### 引用作为参数
```c++
//1.【值传递】如果形参为非引用的传值方式，则生成局部临时变量接收实参的值
void Swap (int left, int right) //值传递的方式无法实现交换，因为传参时对于参数left和right拷贝一临时副本，交换的是副本值，因为其是临时变量函数退出，变量销毁，并不会影响外部left和right的值。
     int temp = left;
     left = right ;
     right = temp ;
}
 
   //2.【引用传递】如果形参为引用类型，则形参是实参的别名。
void Swap (int& left, int& right)//使用引用的话，不做临时拷贝，&的使用说明此处只是原参数的另一个名字而已，所以修改时直接在原参数的基础上修改变量值。
{
     int temp = left;
     right = left ;
     left = temp ;
}
 
    //3.【指针传递】
void Swap (int* pLeft, int* pRight)//传入的是地址，因为地址是唯一的，所以指针通过地址的访问进而可修改其内容。
{
     int temp = *pLeft;
     *pLeft = *pRight;
     *pRight = temp;
}
```
### 引用作为返回值
当函数返回一个引用时，则返回一个指向返回值的**隐式指针**。这样，函数就可以放在赋值语句的**左边**。
```c++
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
 
 
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

输出结果
```
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
```
**注意：返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。**
```c++
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```
## 总结
- 不要返回对临时变量的引用
- 引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。

- 引用必须指向有效的变量，指针可以为空。

- sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。
- 引用比指针更加安全

本次关于指针就讲到这里，下期**结构体**。
> 这是我们**暴走语法堂**系列文章的第`No.2`篇。<br>本系列开始于2022/12/03，主要讲述同学们认为较难的语法部分以及我认为比较重要的语法部分。<br>
	有任何疑问请联系站长，vx：ydcc7910。