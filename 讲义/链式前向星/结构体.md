
# 链式前向星讲义

## 一、链式前向星是什么？
**链式前向星**是一种基于数组模拟链表的图存储方式，常用于**有向图**的边存储。它通过两个数组（`head`和`edge`）高效管理图中所有边的信息，具有**空间利用率高**、**遍历方便**、**实现简单**等优点，是编程竞赛中处理图论问题的常用工具。


## 二、核心原理
### 1. 数据结构定义
- **`head`数组**：长度为顶点数`n`，`head[u]`表示以顶点`u`为起点的**最后一条边**在`edge`数组中的下标。
- **`edge`结构体数组**：每个元素存储一条边的信息，包含：
  - `to`：边的终点（`v`）。
  - `w`：边的权值（若无向图或无权图，可省略）。
  - `next`：指向下一条以`u`为起点的边在`edge`数组中的下标（模拟链表指针）。

### 2. 存储逻辑
- 每条边通过`next`指针形成**链式结构**，同一顶点的所有出边通过`head`数组快速定位。
- 新边总是插入到链表头部，保证遍历顺序与输入顺序相反（但不影响算法正确性）。


## 三、实现步骤

### 1. 初始化
```cpp
const int MAXN = 1e5 + 10; // 最大顶点数
const int MAXM = 2e5 + 10; // 最大边数（无向图需×2）
struct Edge {
    int to, w, next; // 终点、权值、下一条边
} edge[MAXM];
int head[MAXN], cnt; // head[u]为顶点u的边表头，cnt为边计数器

void init() {
    memset(head, -1, sizeof(head)); // 初始时所有顶点无边，head[u] = -1
    cnt = 0; // 边计数器清零
}
```


### 2. 添加边（以有向边为例）
```cpp
void add_edge(int u, int v, int w) {
    edge[cnt].to = v;       // 边的终点为v
    edge[cnt].w = w;       // 边的权值为w
    edge[cnt].next = head[u]; // 新边的next指向当前u的第一条边
    head[u] = cnt++;      // 更新u的第一条边为当前边，cnt自增
}
```

- **无向图处理**：添加两条有向边（`u→v`和`v→u`）。
```cpp
add_edge(u, v, w); // u到v的边
add_edge(v, u, w); // v到u的边（无向图需双向添加）
```


### 3. 遍历顶点u的所有出边
```cpp
void traverse(int u) {
    printf("顶点%d的出边：\n", u);
    for (int i = head[u]; i != -1; i = edge[i].next) { // 从head[u]开始遍历
        int v = edge[i].to;
        int w = edge[i].w;
        printf("→ 终点:%d, 权值:%d\n", v, w);
    }
}
```


## 四、典型应用场景
### 1. 单源最短路径（Dijkstra/Bellman-Ford）
- 用链式前向星存储图，配合优先队列优化的Dijkstra算法，高效处理稀疏图。

### 2. 最小生成树（Kruskal/Prim）
- Prim算法中通过链式前向星遍历邻接边，更新最小边权。

### 3. 拓扑排序
- 遍历每个顶点的出边，维护入度数组，实现拓扑排序。

### 4. 深度优先搜索（DFS）/广度优先搜索（BFS）
- 通过链式前向星快速访问每个顶点的邻接顶点，实现图的遍历。


## 五、完整示例：有向带权图的存储与遍历
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 5; // 顶点数5
const int MAXM = 5; // 边数5

struct Edge {
    int to, w, next;
} edge[MAXM];
int head[MAXN], cnt;

void init() {
    memset(head, -1, sizeof(head));
    cnt = 0;
}

void add_edge(int u, int v, int w) {
    edge[cnt] = {v, w, head[u]}; // C++11初始化方式
    head[u] = cnt++;
}

int main() {
    init();
    // 添加边：1→2（权1），1→3（权2），2→4（权3），3→4（权4），4→5（权5）
    add_edge(1, 2, 1);
    add_edge(1, 3, 2);
    add_edge(2, 4, 3);
    add_edge(3, 4, 4);
    add_edge(4, 5, 5);
    
    // 遍历顶点1的出边
    cout << "顶点1的出边：" << endl;
    for (int i = head[1]; i != -1; i = edge[i].next) {
        cout << "→ 终点:" << edge[i].to << ", 权值:" << edge[i].w << endl;
    }
    // 输出：
    // 顶点1的出边：
    // → 终点:3, 权值:2
    // → 终点:2, 权值:1（注意顺序与输入相反，因头插法）
    return 0;
}
```


## 六、优缺点对比
| **优点** | **缺点** |
|-------------------------|-------------------------|
| 1. 空间紧凑，适合稀疏图 | 1. 不支持动态增删顶点（需预先分配空间） |
| 2. 遍历效率高，时间复杂度O(E) | 2. 边的顺序与输入相反（可能影响某些算法） |
| 3. 无需指针，避免内存泄漏 | 3. 无向图需存储双倍边 |
| 4. 实现简单，代码模板固定 |  |


## 七、注意事项
1. **数组大小**：
   - 有向图：边数为`m`，数组大小需设为`m`。
   - 无向图：每条边存两次，数组大小需设为`2*m`。
2. **初始化**：`head`数组必须初始化为`-1`（或其他无效下标），表示链表终点。
3. **遍历顺序**：由于头插法，遍历顺序与输入顺序相反，如需保持顺序可改用尾插法（需维护`tail`数组）。
4. **权值处理**：无权图可省略`w`字段，结构体中仅保留`to`和`next`。


## 八、常见问题与解决方案
### Q1：如何判断顶点u是否有出边？
A：若`head[u] == -1`，则顶点u无出边。

### Q2：如何删除一条边？
A：链式前向星不支持高效删除操作，如需删除边，需改用邻接表+链表/平衡树实现（但会增加复杂度）。

### Q3：为什么叫“链式前向星”？
A：“链式”指通过链表连接同起点的边，“前向”指边的存储方向与遍历方向一致，“星”指以顶点为中心辐射出多条边的结构。


## 九、拓展：与邻接矩阵的对比
| 特性 | 链式前向星 | 邻接矩阵 |
|-----------------|-------------|-----------|
| 空间复杂度 | O(n + m) | O(n²) |
| 适合场景 | 稀疏图（m << n²） | 稠密图（m ≈ n²） |
| 边查询效率 | O(1)（通过head定位） | O(1) |
| 遍历效率 | O(m) | O(n²) |

**结论**：稀疏图优先使用链式前向星，稠密图优先使用邻接矩阵。


通过链式前向星，我们可以高效地存储和操作图结构，尤其在编程竞赛中，其简洁的实现和高效的性能使其成为图论问题的首选存储方式之一。熟练掌握链式前向星的模板，能显著提升图论算法的编码速度和稳定性。