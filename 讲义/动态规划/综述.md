# 动态规划讲义
编写人：闫鹏博

## 一、动态规划基础概念
动态规划（Dynamic Programming，DP）是一种通过将复杂问题分解为重叠子问题，并利用子问题的解来高效解决原问题的方法。其核心在于避免重复计算，通过存储中间结果（即“记忆化”）来优化递归过程。


### （一）动态规划的两个关键要求
1. **最优子结构**：问题的最优解包含子问题的最优解。
2. **无后效性**：子问题的解一旦确定，不会影响后续子问题的解，即未来与过去无关，仅与当前状态有关。


### （二）动态规划的核心元素
1. **状态定义**：用数学符号（如f[i]）表示子问题的解。
2. **转移方程**：描述状态之间的递推关系。
3. **初始条件**：最小子问题的解（基底情况）。


## 二、经典动态规划例题分析

### （一）楼梯问题
**问题描述**：有n级台阶，每次可走1级或2级，求从第0级走到第n级的走法总数。
**例子**：计算10级台阶的走法数（每次走1或2级）

#### 状态转移表格
| 台阶数i | 走法数f[i] | 转移过程解释                                                                 |
|---------|------------|------------------------------------------------------------------------------|
| 0       | 1          | 初始条件：原地不动，1种走法                                                   |
| 1       | 1          | 只能走1级，1种走法                                                           |
| 2       | f(1)+f(0)=1+1=2 | 从第1级走1步或第0级走2步到达第2级                                           |
| 3       | f(2)+f(1)=2+1=3 | 从第2级走1步或第1级走2步到达第3级                                           |
| 4       | f(3)+f(2)=3+2=5 | 同上，递推计算                                                               |
| 5       | f(4)+f(3)=5+3=8 |                                                                              |
| 6       | f(5)+f(4)=8+5=13 |                                                                              |
| 7       | f(6)+f(5)=13+8=21 |                                                                              |
| 8       | f(7)+f(6)=21+13=34 |                                                                              |
| 9       | f(8)+f(7)=34+21=55 |                                                                              |
| 10      | f(9)+f(8)=55+34=89 | 最终结果：89种走法                                                           |

#### 关键说明
- **模型特点**：状态转移满足斐波那契数列规律，f(n) = f(n-1) + f(n-2)
- **表格核心**：每一行的f[i]仅依赖前两行的结果，体现“无后效性”（后续计算不关心前面如何走到i-1或i-2级，只关心走法数）

#### 1. 问题分析
- **递归解法**：f(n) = f(n-1) + f(n-2)，但存在大量重复计算（如计算f(5)时会重复计算f(3)和f(4)）。
- **动态规划优化**：从前往后计算，存储中间结果，避免重复。

#### 2. 状态与转移
- **状态定义**：f[i]表示走到第i级台阶的走法数。
- **转移方程**：f[i] = f[i-1] + f[i-2]（第i级可由第i-1级走1步或第i-2级走2步到达）。
- **初始条件**：f[0] = 1（原地不动），f[1] = 1（走1步）。

#### 3. 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long long f[51]; // 存储走法数，n≤50时用long long避免溢出
int main() {
    scanf("%d", &n);
    f[0] = 1; f[1] = 1;
    for (int i = 2; i <= n; i++)
        f[i] = f[i-1] + f[i-2];
    printf("%lld\n", f[n]);
    return 0;
}
```

#### 4. 重点总结
- **核心思想**：将递归的“自顶向下”转化为动态规划的“自底向上”，通过存储中间结果优化时间复杂度（从O(2ⁿ)降至O(n)）。
- **状态设计**：f[i]直接对应问题目标，转移方程符合分步选择逻辑。


### （二）有向图最短路问题
**问题描述**：有向图中，只能从编号小的点走到编号大的点，求从1号点到n号点的最短时间。

#### 1. 问题分析
- **图结构**：n个点，m条边，边权为时间，u < v时存在u→v的边。
- **动态规划适用性**：路径具有顺序性（编号递增），满足最优子结构和无后效性。

#### 2. 状态与转移
- **状态定义**：f[y]表示从1号点到y号点的最短时间。
- **转移方程**：f[y] = min{f[x] + w | 存在边x→y且x < y}。
- **初始条件**：f[1] = 0（起点时间为0），其他点初始化为无穷大。

#### 3. 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int a[1001][1001], f[1001], n, m; // a[x][y]存储x到y的最小边权
int main() {
    scanf("%d%d", &n, &m);
    memset(a, INF, sizeof(a));
    for (int i = 1; i <= m; i++) {
        int x, y, w;
        scanf("%d%d%d", &x, &y, &w);
        a[x][y] = min(a[x][y], w); // 处理重边
    }
    memset(f, INF, sizeof(f));
    f[1] = 0;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            if (f[j] != INF && a[j][i] != INF)
                f[i] = min(f[i], f[j] + a[j][i]);
    printf("%d\n", f[n]);
    return 0;
}
```

#### 4. 重点总结
- **状态设计**：f[y]聚焦于单点最短时间，忽略路径细节，满足无后效性。
- **转移逻辑**：按节点编号顺序遍历，确保计算f[y]时，所有可能的前驱节点f[x]已计算完成。
- **数据结构**：用邻接矩阵存储边权，适用于n≤1000的规模。


### （三）最长上升子序列（LIS）
**问题描述**：给定数组，求最长严格递增子序列的长度。
**例子**：数组 `[3, 7, 4, 2, 6, 8]` 的最长上升子序列长度

#### 状态转移表格
| 元素下标i | 元素值a[i] | 以i结尾的LIS长度f[i] | 转移过程解释                                                                 |
|-----------|------------|----------------------|------------------------------------------------------------------------------|
| 1         | 3          | 1                    | 单个元素，长度为1                                                            |
| 2         | 7          | f(1)+1=2            | 7>3，以7结尾的子序列长度为3结尾的长度+1                                      |
| 3         | 4          | max(f(1)+1=2)       | 4>3，比7小，所以找前面比4小的元素（3），f(3)=f(1)+1=2                       |
| 4         | 2          | 1                    | 2比前面所有元素小，无法接在任何子序列后，只能自身成序列                      |
| 5         | 6          | max(f(1)+1=2, f(3)+1=3) =3 | 6>3和4，取最长的前驱（f(3)=2→3）                                            |
| 6         | 8          | max(f(1)+1=2, f(2)+1=3, f(3)+1=3, f(5)+1=4) =4 | 8>所有前驱，取最长的前驱（f(5)=3→4）                                        |

#### 关键说明
- **模型特点**：状态f[i]表示“以第i个元素结尾”的最优解，需遍历所有j<i且a[j]<a[i]的状态
- **表格核心**：f[i]的取值依赖于前面所有更小元素的状态，体现“最优子结构”（最长子序列可由前面的短子序列扩展而来）
#### 1. 问题分析
- **子序列定义**：无需连续，但顺序必须递增。
- **动态规划思路**：以每个位置结尾的最长子序列长度可由前面更小元素的子序列长度推导。

#### 2. 状态与转移
- **状态定义**：f[i]表示以数组第i个元素结尾的最长上升子序列长度。
- **转移方程**：f[i] = max{f[j] + 1 | j < i且a[j] < a[i]}。
- **初始条件**：f[i] = 1（单个元素本身是长度为1的子序列）。

#### 3. 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[1001], f[1001];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j < i; j++)
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, f[i]);
    printf("%d\n", ans);
    return 0;
}
```

#### 4. 重点总结
- **状态设计**：以“结尾位置”定义状态，将问题转化为局部最优解的组合。
- **转移逻辑**：遍历所有前驱元素，找到能使当前子序列最长的前驱状态。
- **时间复杂度**：O(n²)，适用于n≤1000的场景（优化解法可降至O(n log n)，但此处未展开）。


### （四）最长公共子序列（LCS）
**问题描述**：给定两个数组a和b，求它们的最长公共子序列长度。

**例子**：数组 `a=[3,2,4,5,3,2]` 和 `b=[4,3,5,1,2]` 的最长公共子序列长度

#### 状态转移表格（f[i][j]表示a前i个与b前j个的LCS长度）

| j\i       | 0（空序列） | 1(3)       | 2(2)       | 3(4)       | 4(5)       | 5(3)       | 6(2)       |
|-----------|-------------|------------|------------|------------|------------|------------|------------
| 0（空序列） | 0           | 0          | 0          | 0          | 0          | 0          | 0          |
| 1(4)      | 0           | 0          | 0          | f(2,0)+1=1 | 1          | 1          | 1          |
| 2(3)      | 0           | f(1,1)+1=1 | 1          | 1          | 1          | f(5,1)+1=2 | 2          |
| 3(5)      | 0           | 1          | 1          | 1          | f(4,2)+1=2 | 2          | 2          |
| 4(1)      | 0           | 1          | 1          | 1          | 2          | 2          | 2          |
| 5(2)      | 0           | 1          | f(2,4)+1=2 | 2          | 2          | 2          | f(6,4)+1=3 |

#### 关键位置解释
1. **i=3,j=1（a[3]=4，b[1]=4）**：  
   a[3]=b[1]，所以f(3,1)=f(2,0)+1=1（前i-1=2和j-1=0的LCS长度+1）
2. **i=5,j=2（a[5]=3，b[2]=3）**：  
   a[5]=b[2]，f(5,2)=f(4,1)+1=1+1=2（前i-1=4和j-1=1的LCS长度为1）
3. **i=6,j=5（a[6]=2，b[5]=2）**：  
   a[6]=b[5]，f(6,5)=f(5,4)+1=2+1=3（前i-1=5和j-1=4的LCS长度为2）

#### 关键说明
- **模型特点**：二维状态同时处理两个序列的匹配，转移时考虑“匹配”和“不匹配”两种情况
- **表格核心**：每格f[i][j]的值由左、上或左上的格子推导而来，体现“子问题重叠”特性（如f(6,5)依赖f(5,4)）

#### 1. 问题分析
- **公共子序列**：元素在两个数组中顺序一致，但不要求连续。
- **动态规划思路**：通过二维状态表示两个数组前缀的匹配情况。

#### 2. 状态与转移
- **状态定义**：f[i][j]表示a的前i个元素和b的前j个元素的最长公共子序列长度。
- **转移方程**：
  - 若a[i] = b[j]，则f[i][j] = f[i-1][j-1] + 1（匹配当前元素）；
  - 否则，f[i][j] = max(f[i-1][j], f[i][j-1])（不匹配时取两种前缀的最大值）。
- **初始条件**：f[0][j] = 0，f[i][0] = 0（空序列长度为0）。

#### 3. 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[1001], b[1001], f[1001][1001];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= m; i++)
        scanf("%d", &b[i]);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if (a[i] == b[j])
                f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        }
    printf("%d\n", f[n][m]);
    return 0;
}
```

#### 4. 重点总结
- **状态设计**：二维数组同时考虑两个数组的前缀，覆盖所有可能的匹配情况。
- **转移逻辑**：分“匹配”和“不匹配”两种情况，体现最优子结构。
- **空间优化**：若n和m较大，可优化为一维数组（需逆序遍历），但此处采用直观的二维实现。


## 三、动态规划类型总结
| **问题类型**       | **状态定义**                          | **转移核心**                          | **关键技巧**                          |
|--------------------|---------------------------------------|---------------------------------------|---------------------------------------|
| 楼梯问题           | f[i]：到第i级的走法数                | f[i] = f[i-1] + f[i-2]                | 斐波那契数列的动态规划转化            |
| 有向图最短路       | f[y]：到y点的最短时间                | f[y] = min(f[x] + w)（x是y的前驱）    | 按顺序遍历节点，避免后效性            |
| 最长上升子序列     | f[i]：以i结尾的最长子序列长度        | f[i] = max(f[j]+1)（j < i且a[j] < a[i]）| 聚焦“结尾”状态，遍历前驱找最优        |
| 最长公共子序列     | f[i][j]：a前i和b前j的LCS长度        | 分匹配与不匹配转移                    | 二维状态处理双序列匹配                |


## 四、动态规划解题通用步骤
1. **分析问题**：确定是否具有最优子结构和无后效性。
2. **定义状态**：用f[i]或f[i][j]等符号表示子问题的解，需直接关联问题目标。
3. **推导转移方程**：分析子问题之间的关系，建立状态递推公式。
4. **设定初始条件**：处理最小子问题（如f[0]、f[1]）。
5. **确定计算顺序**：从底向上计算，确保转移时依赖的状态已求解。
6. **编写代码**：注意数组边界、初始化方式和数据类型溢出问题。


## 五、思考题：最长回文子串（提示思路）
**问题描述**：求字符串中最长的回文子串长度。
**动态规划思路**：
- **状态定义**：f[i][j]表示子串s[i...j]是否为回文子串。
- **转移方程**：若s[i] = s[j]，则f[i][j] = f[i+1][j-1]（当j-i ≤ 1时直接为真）。
- **关键**：按子串长度从小到大计算，先处理短子串，再推导长子串。

（具体代码可参考动态规划的二维数组实现，此处略）


**总结**：动态规划的核心在于“分解问题、记忆子解、递推求解”。不同问题的状态设计是解题的关键，需通过大量练习掌握常见模型（如背包问题、区间DP等），并灵活应用最优子结构和无后效性原则。