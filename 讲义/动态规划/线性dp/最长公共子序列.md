# 最长公共子序列（LCS）
## 一、题目描述
给定两个字符串 `a` 和 `b`，找出它们最长的公共子序列的长度。子序列是指由原序列中的某些元素（字符）按顺序组成，但不一定连续的序列。例如，对于字符串 `abcde` 和 `ace`，最长公共子序列是 `ace`，长度为 3 。

## 二、做题分析步骤
### （一）问题拆解
要找两个字符串的最长公共子序列，可从最后一个字符开始分析：
1. 若 `a` 的第 `i` 个字符和 `b` 的第 `j` 个字符相等（`a[i] == b[j]` ），那这个字符肯定在最长公共子序列里，此时只需找 `a` 前 `i - 1` 个字符和 `b` 前 `j - 1` 个字符的最长公共子序列，再加上当前这个相等字符。
2. 若 `a[i] != b[j]` ，那最长公共子序列要么不包含 `a[i]` （此时看 `a` 前 `i - 1` 个字符和 `b` 前 `j` 个字符的最长公共子序列 ），要么不包含 `b[j]` （此时看 `a` 前 `i` 个字符和 `b` 前 `j - 1` 个字符的最长公共子序列 ），取这两种情况里的最大值。

### （二）推导方向
从字符串的前几个字符逐步推导到整个字符串，用动态规划的思想，把大问题拆成小问题，通过解决小问题来得到大问题的解。

## 三、重点知识笔记
### （一）动态规划状态定义
定义 `f[i][j]` 为字符串 `a` 的前 `i` 个字符和字符串 `b` 的前 `j` 个字符的最长公共子序列的长度 。

### （二）转移方程推理过程
1. **情况一：`a[i] == b[j]`**  
此时，`a` 的第 `i` 个字符和 `b` 的第 `j` 个字符可加入公共子序列。因为前面 `a` 的前 `i - 1` 个字符和 `b` 的前 `j - 1` 个字符的最长公共子序列长度是 `f[i - 1][j - 1]` ，加上当前相等字符，所以 `f[i][j] = f[i - 1][j - 1] + 1` 。  
2. **情况二：`a[i] != b[j]`**  
此时有两种可能：
    - 公共子序列不包含 `a[i]` ，那么最长公共子序列长度就是 `a` 前 `i - 1` 个字符和 `b` 前 `j` 个字符的最长公共子序列长度，即 `f[i - 1][j]` 。
    - 公共子序列不包含 `b[j]` ，那么最长公共子序列长度就是 `a` 前 `i` 个字符和 `b` 前 `j - 1` 个字符的最长公共子序列长度，即 `f[i][j - 1]` 。  
所以这种情况下，`f[i][j] = max(f[i - 1][j], f[i][j - 1])` 。  

综上，完整转移方程：  
$$
f[i][j] = 
\begin{cases} 
f[i - 1][j - 1] + 1, & a[i] == b[j] \\
\max(f[i - 1][j], f[i][j - 1]), & a[i] != b[j] 
\end{cases}
$$

### （三）初始条件
- 当 `i = 0` （`a` 没有字符 ），不管 `b` 多长，最长公共子序列长度是 0 ，即 `f[0][j] = 0`（`j` 为任意 ）。
- 当 `j = 0` （`b` 没有字符 ），不管 `a` 多长，最长公共子序列长度是 0 ，即 `f[i][0] = 0`（`i` 为任意 ）。

## 四、代码实现
### （一）朴素版（二维数组实现）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main()
{
    cin >> n >> m;
    cin >> a + 1 >> b + 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if(a[i] == b[j])
                f[i][j] =  f[i - 1][j - 1] + 1;
            else 
                f[i][j] = max ( f[i - 1][j], f[i][j - 1]);
        }
    cout << f[n][m] << endl;
    return 0;
}
```
**思路**：用二维数组 `f` 存储每个 `i` 和 `j` 对应的最长公共子序列长度，按转移方程逐行逐列计算，最后 `f[m][n]` 就是结果。空间复杂度为 $O(m \times n)$ ，`m`、`n` 是两个字符串长度。

### （二）优化版（滚动数组，空间优化）
观察转移方程，计算 `f[i][j]` 时，主要用到 `f[i - 1][j - 1]`、`f[i - 1][j]`（上一行 ）和 `f[i][j - 1]`（当前行前一列 ）。可通过滚动数组，用一维数组优化空间。
```python
def longestCommonSubsequenceOpt(a, b):
    m, n = len(a), len(b)
    # 让一维数组长度为较短字符串长度 + 1，优化空间
    if m < n:
        a, b = b, a
        m, n = n, m
    f = [0] * (n + 1)
    for i in range(1, m + 1):
        prev = 0  # 保存 f[i - 1][j - 1] 的值
        for j in range(1, n + 1):
            temp = f[j]  # 保存当前 j 位置原来的值，即 f[i - 1][j]
            if a[i - 1] == b[j - 1]:
                f[j] = prev + 1
            else:
                f[j] = max(f[j], f[j - 1])
            prev = temp  # 更新 prev 为下一轮的 f[i - 1][j - 1]
    return f[n]

# 测试
a = "abcde"
b = "ace"
print(longestCommonSubsequenceOpt(a, b))  
```
**思路**：通过滚动数组，把二维数组优化成一维数组。利用 `prev` 保存 `f[i - 1][j - 1]` ，`temp` 保存 `f[i - 1][j]` ，按转移方程更新一维数组的值。空间复杂度优化为 $O(\min(m, n))$ ，更节省内存，适合处理长字符串情况。 