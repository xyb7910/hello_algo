# 最长上升子序列（LIS）笔记
## 一、题目描述  
给定一个整数数组 `nums`，找到**最长严格递增子序列**的长度（子序列是由数组派生而来，删除元素而不改变剩余元素相对顺序，如 `[3,6,2,7]` 是 `[3,1,6,2,7]` 的子序列 ）。  
## 二、做题分析步骤  
### 1. 问题拆解  
要找最长上升子序列，需关注**以每个元素结尾**的子序列长度：  
- 若能确定“以 `nums[i]` 结尾的最长上升子序列长度”，遍历所有 `i` 取最大值，就是最终结果。  
### 2. 动态规划思路  
- **状态定义**：`f[i]` 表示以 `nums[i]` 结尾的最长上升子序列长度。  
- **转移逻辑**：对于 `nums[i]`，向前找所有 `nums[j] < nums[i]`（`j < i`），则 `f[i]` 可由 `f[j] + 1` 转移而来（在 `f[j]` 基础上拼接 `nums[i]` 形成更长上升子序列 ）。  
- **初始状态**：每个元素自身可构成长度为 `1` 的子序列，即 `f[i] = 1`（`i` 遍历数组所有下标）。  
## 三、重点知识笔记  
### 1. 核心逻辑  
- 子序列“上升”要求：严格递增（`nums[j] < nums[i]` ，若题目是“非严格递增”则条件改为 `nums[j] <= nums[i]` ）。  
- 状态 `f[i]` 聚焦“以 `i` 结尾”，通过枚举前驱 `j` 推导，体现动态规划**递推依赖**思想。  
### 2. 时间复杂度分析（朴素版）  
- 枚举每个 `i`（共 `n` 个），每个 `i` 需枚举 `j`（最多 `i-1` 次 ），总操作次数约 $\frac{n(n-1)}{2}$ ，时间复杂度为 $O(n^2)$ （`n` 是数组长度 ）。 
## 四、转移方程推理过程  
1. 定义 `f[i]` 为以 `nums[i]` 结尾的最长上升子序列长度。  
2. 对于 `nums[i]`，要找前面比它小的元素 `nums[j]`（`j < i`）：  
   - 若 `nums[j] < nums[i]`，则以 `nums[j]` 结尾的子序列后拼接 `nums[i]`，长度为 `f[j] + 1`。  
   - 遍历所有符合条件的 `j`，取最大的 `f[j] + 1` 作为 `f[i]` 的值（若没有符合条件的 `j`，`f[i]` 保持初始值 `1` ）。  
3. 因此，转移方程为：  
   $$ f[i] = \max\left\{ f[j] + 1 \mid 0 \leq j < i \ \text{且} \ \text{nums}[j] < \text{nums}[i] \right\} $$
## 五、代码实现  
### 1. 朴素版（$O(n^2)$ 复杂度 ）  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, a[N], f[N], ans;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++)
            if(a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
        ans = max(ans, f[i]);
    }
    cout << ans;
    return 0;
}
```
### 2. 优化版（$O(n \log n)$ 复杂度 ）  
**思路**：维护一个数组 `q`，`q[k]` 表示长度为 `k+1` 的上升子序列的最小末尾元素。遍历 `a` 时，用二分查找确定当前元素可插入位置，更新 `q`，最终 `q` 长度即答案。  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, a[N], q[N];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++)
        scanf("%d", &a[i]);
    int len = 0;
    q[0] = -1e9;
    for (int i = 1; i <= n; i ++ )
    {
        int l = 0, r = len;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
    printf("%d", len);
    return 0;
}
```  
**优化点**：用二分查找替代暴力枚举 `j`，将时间复杂度从 $O(n^2)$ 降为 $O(n \log n)$ ，适合处理大规模数据。  
（注：若题目要求**严格递增**，调整二分条件为 `tails[mid] > num` 即可；非严格递增则保持 `>=` 逻辑 。）