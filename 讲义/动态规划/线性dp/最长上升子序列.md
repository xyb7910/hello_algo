# 最长上升子序列（LIS）笔记
## 一、题目描述  
给定一个整数数组 `nums`，找到**最长严格递增子序列**的长度（子序列是由数组派生而来，删除元素而不改变剩余元素相对顺序，如 `[3,6,2,7]` 是 `[3,1,6,2,7]` 的子序列 ）。  


## 二、做题分析步骤  
### 1. 问题拆解  
要找最长上升子序列，需关注**以每个元素结尾**的子序列长度：  
- 若能确定“以 `nums[i]` 结尾的最长上升子序列长度”，遍历所有 `i` 取最大值，就是最终结果。  

### 2. 动态规划思路  
- **状态定义**：`f[i]` 表示以 `nums[i]` 结尾的最长上升子序列长度。  
- **转移逻辑**：对于 `nums[i]`，向前找所有 `nums[j] < nums[i]`（`j < i`），则 `f[i]` 可由 `f[j] + 1` 转移而来（在 `f[j]` 基础上拼接 `nums[i]` 形成更长上升子序列 ）。  
- **初始状态**：每个元素自身可构成长度为 `1` 的子序列，即 `f[i] = 1`（`i` 遍历数组所有下标）。  


## 三、重点知识笔记  
### 1. 核心逻辑  
- 子序列“上升”要求：严格递增（`nums[j] < nums[i]` ，若题目是“非严格递增”则条件改为 `nums[j] <= nums[i]` ）。  
- 状态 `f[i]` 聚焦“以 `i` 结尾”，通过枚举前驱 `j` 推导，体现动态规划**递推依赖**思想。  

### 2. 时间复杂度分析（朴素版）  
- 枚举每个 `i`（共 `n` 个），每个 `i` 需枚举 `j`（最多 `i-1` 次 ），总操作次数约 $\frac{n(n-1)}{2}$ ，时间复杂度为 $O(n^2)$ （`n` 是数组长度 ）。  


## 四、转移方程推理过程  
1. 定义 `f[i]` 为以 `nums[i]` 结尾的最长上升子序列长度。  
2. 对于 `nums[i]`，要找前面比它小的元素 `nums[j]`（`j < i`）：  
   - 若 `nums[j] < nums[i]`，则以 `nums[j]` 结尾的子序列后拼接 `nums[i]`，长度为 `f[j] + 1`。  
   - 遍历所有符合条件的 `j`，取最大的 `f[j] + 1` 作为 `f[i]` 的值（若没有符合条件的 `j`，`f[i]` 保持初始值 `1` ）。  
3. 因此，转移方程为：  
   $$ f[i] = \max\left\{ f[j] + 1 \mid 0 \leq j < i \ \text{且} \ \text{nums}[j] < \text{nums}[i] \right\} $$  


## 五、代码实现  
### 1. 朴素版（$O(n^2)$ 复杂度 ）  
```python
def lengthOfLIS(nums):
    n = len(nums)
    if n == 0:
        return 0
    # 初始化 dp 数组，每个元素自身构成长度为1的子序列
    f = [1] * n  
    for i in range(n):
        # 遍历 i 之前的元素 j
        for j in range(i):  
            if nums[j] < nums[i]:  
                # 若 nums[j] 小于 nums[i]，尝试更新 f[i]
                f[i] = max(f[i], f[j] + 1)  
    # 所有 f[i] 中的最大值即为最长上升子序列长度
    return max(f)  
```

### 2. 优化版（$O(n \log n)$ 复杂度 ）  
**思路**：维护一个数组 `tails`，`tails[k]` 表示长度为 `k+1` 的上升子序列的**最小末尾元素**。遍历 `nums` 时，用二分查找确定当前元素可插入位置，更新 `tails`，最终 `tails` 长度即答案。  

```python
def lengthOfLIS(nums):
    tails = []
    for num in nums:
        # 二分查找 num 应插入的位置（找第一个 >= num 的元素位置，严格递增则找 >）
        left, right = 0, len(tails)
        while left < right:
            mid = (left + right) // 2
            if tails[mid] >= num:  # 非严格递增用 >=，严格递增用 >
                right = mid
            else:
                left = mid + 1
        if left == len(tails):
            tails.append(num)
        else:
            tails[left] = num
    return len(tails)
```  

**优化点**：用二分查找替代暴力枚举 `j`，将时间复杂度从 $O(n^2)$ 降为 $O(n \log n)$ ，适合处理大规模数据。  

（注：若题目要求**严格递增**，调整二分条件为 `tails[mid] > num` 即可；非严格递增则保持 `>=` 逻辑 。）