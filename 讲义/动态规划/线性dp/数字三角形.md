以下是关于数字三角形问题的完整笔记，包含题目描述、分析步骤、知识笔记、转移方程推理及代码实现：

---

### **一、题目描述**  
给定一个数字三角形（如截图所示，第 `i` 行有 `i` 个数字 ），从顶端出发，每次只能**向下或向右下**走，路径经过的数字之和为路径和。求**所有路径中路径和的最大值**。  


### **二、做题分析步骤**  
1. **问题拆解**：  
   需找到从顶端到最底层的所有路径中，数字和最大的路径。直接暴力枚举所有路径会有指数级复杂度（第 `n` 层有 $2^{n-1}$ 条路径 ），需用动态规划优化。  

2. **动态规划核心思路**：  
   - **状态定义**：用 `f[i][j]` 表示“从顶端走到第 `i` 行、第 `j` 列（行列均从 1 开始）时的最大路径和”。  
   - **状态转移**：观察路径来源，`f[i][j]` 只能由**左上方（`f[i-1][j-1]`）**或**正上方（`f[i-1][j]`）**转移而来（结合数字三角形的走法逻辑）。  
   - **结果输出**：遍历最后一行的 `f[n][1..n]`，取最大值。  


### **三、重点知识笔记**  
1. **动态规划三要素**：  
   - **状态表示**：`f[i][j]` 代表“走到第 `i` 行第 `j` 列的所有路径”的**最大和**（集合 + 属性）。  
   - **状态计算**：通过子问题（`i-1` 行的状态）推导当前状态，需枚举所有可能的来源。  
   - **边界条件**：顶端 `f[1][1] = a[1][1]`（`a` 为存储数字三角形的数组 ）。  

2. **转移方向的逻辑**：  
   数字三角形的走法限制（向下或向右下），对应状态转移时，`f[i][j]` 的来源是 **`f[i-1][j-1]`（左上）** 和 **`f[i-1][j]`（正上）**，需确保下标不越界（如 `j=1` 时，只有正上来源）。  


### **四、转移方程推理过程**  
1. **初始状态**：  
   顶端只有一个数字，即 `f[1][1] = a[1][1]`（第 1 行第 1 列 ）。  

2. **推导通用转移**：  
   对于第 `i` 行第 `j` 列（`i ≥ 2`）：  
   - 若从**左上**（`i-1` 行 `j-1` 列）走来：贡献为 `f[i-1][j-1] + a[i][j]`。  
   - 若从**正上**（`i-1` 行 `j` 列）走来：贡献为 `f[i-1][j] + a[i][j]`。  
   因此，转移方程为：  
   $$ f[i][j] = \max\left\{ f[i-1][j-1],\ f[i-1][j] \right\} + a[i][j] $$  

3. **边界处理**：  
   - 当 `j = 1` 时，无左上来源，只能由正上转移：`f[i][1] = f[i-1][1] + a[i][1]`。  
   - 当 `j = i` 时（每行最右端），无正上来源（上一行只有 `i-1` 列），只能由左上转移：`f[i][i] = f[i-1][i-1] + a[i][i]`。  


### **五、代码实现**  
#### **1. 朴素版（二维数组，空间复杂度 $O(n^2)$）**  
```python
n = int(input())  # 数字三角形的行数
a = []
for _ in range(n):
    row = list(map(int, input().split()))
    a.append([0] + row)  # 前面补0，让列下标从1开始（方便处理边界）

# 初始化dp数组
f = [[0]*(n+1) for _ in range(n+1)]
f[1][1] = a[0][1]  # 顶端元素（a[0]是第一行，因补0后列从1开始）

for i in range(2, n+1):          # 遍历第2行到第n行
    for j in range(1, i+1):      # 遍历第1列到第i列
        if j == 1:               # 最左端，只能来自正上
            f[i][j] = f[i-1][j] + a[i-1][j]
        elif j == i:             # 最右端，只能来自左上
            f[i][j] = f[i-1][j-1] + a[i-1][j]
        else:                    # 中间位置，取两种来源的最大值
            f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i-1][j]

# 最后一行的最大值即为答案
print(max(f[n][1: n+1]))
```  

#### **2. 优化版（一维数组，空间复杂度 $O(n)$）**  
观察转移方程，`f[i][j]` 仅依赖 **`f[i-1][j-1]` 和 `f[i-1][j]`**（即上一行的状态 ）。可用**滚动数组**优化空间，将二维 `f` 压缩为一维：  

```python
n = int(input())
a = []
for _ in range(n):
    row = list(map(int, input().split()))
    a.append([0] + row)  # 列下标从1开始

# 优化为一维数组，f[j] 表示当前行第j列的最大路径和
f = [0]*(n+2)  # 多开空间避免越界
f[1] = a[0][1]

for i in range(2, n+1):
    # 逆序遍历j（避免覆盖需要的上一行状态）
    for j in range(i, 0, -1):  
        if j == 1:
            f[j] = f[j] + a[i-1][j]  # 等价于 f[i-1][j]（因j=1时无左上干扰）
        elif j == i:
            f[j] = f[j-1] + a[i-1][j]  # 等价于 f[i-1][j-1]
        else:
            f[j] = max(f[j-1], f[j]) + a[i-1][j]

print(max(f[1: n+1]))
```  

**优化逻辑**：  
- 一维数组 `f` 存储**当前行**的状态，逆序遍历 `j` 可保证计算 `f[j]` 时，`f[j-1]` 仍保留**上一行**的数据（避免正向遍历导致覆盖 ）。  


### **六、总结**  
- 核心是动态规划的**状态定义**与**转移方程**，通过子问题最优解推导全局最优。  
- 空间优化利用“滚动数组”，将二维降为一维，适合处理类似“仅依赖上一行”的状态转移问题。  
- 数字三角形是动态规划的经典入门题，掌握后可迁移到“最长路径”“最小路径和”等衍生问题。