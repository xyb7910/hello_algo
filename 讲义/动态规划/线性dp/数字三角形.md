
### **一、题目描述**  
给定一个数字三角形（如截图所示，第 `i` 行有 `i` 个数字 ），从顶端出发，每次只能**向下或向右下**走，路径经过的数字之和为路径和。求**所有路径中路径和的最大值**。  


### **二、做题分析步骤**  
1. **问题拆解**：  
   需找到从顶端到最底层的所有路径中，数字和最大的路径。直接暴力枚举所有路径会有指数级复杂度（第 `n` 层有 $2^{n-1}$ 条路径 ），需用动态规划优化。  

2. **动态规划核心思路**：  
   - **状态定义**：用 `f[i][j]` 表示“从顶端走到第 `i` 行、第 `j` 列（行列均从 1 开始）时的最大路径和”。  
   - **状态转移**：观察路径来源，`f[i][j]` 只能由**左上方（`f[i-1][j-1]`）**或**正上方（`f[i-1][j]`）**转移而来（结合数字三角形的走法逻辑）。  
   - **结果输出**：遍历最后一行的 `f[n][1..n]`，取最大值。  


### **三、重点知识笔记**  
1. **动态规划三要素**：  
   - **状态表示**：`f[i][j]` 代表“走到第 `i` 行第 `j` 列的所有路径”的**最大和**（集合 + 属性）。  
   - **状态计算**：通过子问题（`i-1` 行的状态）推导当前状态，需枚举所有可能的来源。  
   - **边界条件**：顶端 `f[1][1] = a[1][1]`（`a` 为存储数字三角形的数组 ）。  

2. **转移方向的逻辑**：  
   数字三角形的走法限制（向下或向右下），对应状态转移时，`f[i][j]` 的来源是 **`f[i-1][j-1]`（左上）** 和 **`f[i-1][j]`（正上）**，需确保下标不越界（如 `j=1` 时，只有正上来源）。  


### **四、转移方程推理过程**  
1. **初始状态**：  
   顶端只有一个数字，即 `f[1][1] = a[1][1]`（第 1 行第 1 列 ）。  

2. **推导通用转移**：  
   对于第 `i` 行第 `j` 列（`i ≥ 2`）：  
   - 若从**左上**（`i-1` 行 `j-1` 列）走来：贡献为 `f[i-1][j-1] + a[i][j]`。  
   - 若从**正上**（`i-1` 行 `j` 列）走来：贡献为 `f[i-1][j] + a[i][j]`。  
   因此，转移方程为：  
   $$ f[i][j] = \max\left\{ f[i-1][j-1],\ f[i-1][j] \right\} + a[i][j] $$  

3. **边界处理**：  
   - 当 `j = 1` 时，无左上来源，只能由正上转移：`f[i][1] = f[i-1][1] + a[i][1]`。  
   - 当 `j = i` 时（每行最右端），无正上来源（上一行只有 `i-1` 列），只能由左上转移：`f[i][i] = f[i-1][i-1] + a[i][i]`。  


### **五、代码实现**  
#### **1. 朴素版（二维数组，空间复杂度 $O(n^2)$）**  
从上至下，输入从 `1` 开始的话，就不需要处理边界；如果题目中的数组`a[i][j]` 涉及到负数，所以在计算的过程中需要将 `f` 数组初始化为 `负无穷`。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 510, INF = -0x3f3f3f3f;
int a[N][N], f[N][N], n, ans = INF;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++)
            scanf("%d", &a[i][j]);
    memset(f, INF, sizeof f);
    f[1][1] = a[1][1];
    for (int i = 2; i <= n; i ++)
        for (int j = 1; j <= i; j ++)
            f[i][j] = max(f[i - 1][j], f[i - 1][j - 1]) + a[i][j];
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[n][i]);
    printf("%d", ans);
    return 0;
}
```  
从下至上，不需要处理边界，也不需要将 `f` 数组初始化为 `负无穷`。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 510;
int a[N][N], f[N][N], n;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++)
            scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i ++) f[n][i] = a[n][i];
    for (int i = n - 1; i >= 1; i --)
        for (int j = i; j >= 1; j --)
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];
    printf("%d", f[1][1]);
    return 0;
}
```
