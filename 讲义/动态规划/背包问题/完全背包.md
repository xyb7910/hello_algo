# 完全背包问题笔记
## 一、题目描述
有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的体积是 $v[i]$，价值是 $w[i]$。求在不超过背包容量的情况下，选取物品的最大价值总和。 

## 二、做题分析步骤
### （一）问题拆解
要解决完全背包问题，需确定在考虑前 $i$ 种物品、背包容量为 $j$ 时的最大价值。由于每种物品数量无限，需合理规划状态转移，高效计算不同选取组合下的价值。 

### （二）核心思路
利用动态规划，定义状态 $f[i][j]$ 表示前 $i$ 种物品、背包容量为 $j$ 时的最大价值。通过分析第 $i$ 种物品的选取数量（$0$ 到最多能放的数量），推导状态转移关系，再优化计算过程降低时间复杂度 。

## 三、重点知识笔记
### （一）状态表示
- **集合**：$f[i][j]$ 代表所有只考虑前 $i$ 个物品，且总体积不超过 $j$ 的选法集合 。
- **属性**：求该集合中价值的最大值（$\text{Max}$）。

### （二）状态计算（集合划分）
对于第 $i$ 种物品，选取数量 $k$ 可以是 $0,1,2,\dots$（只要 $k \times v[i] \leq j$）。此时状态转移的朴素思路为：  
$$ f[i][j] = \max\{ f[i - 1][j - k \times v[i]] + k \times w[i] \mid k = 0,1,2,\dots \} $$ 
当 $k = 0$ 时，就是不选第 $i$ 种物品的情况，对应 $f[i - 1][j]$ 。

## 四、转移方程推理过程
### （一）朴素转移逻辑
最初，考虑第 $i$ 种物品选 $k$ 个，需从 $f[i - 1][j - k \times v[i]]$ 转移而来（加上 $k$ 个物品的价值 $k \times w[i]$ ），要遍历所有可能的 $k$ 值找最大值，即：  
$$ f[i][j] = \max(f[i - 1][j], f[i - 1][j - v[i]] + w[i], f[i - 1][j - 2v[i]] + 2w[i], \dots) $$  

### （二）优化推导
观察 $f[i][j - v[i]]$ 的计算式：  
$$ f[i][j - v[i]] = \max(f[i - 1][j - v[i]], f[i - 1][j - 2v[i]] + w[i], f[i - 1][j - 3v[i]] + 2w[i], \dots) $$  
对比 $f[i][j]$ 的朴素式，可发现 $f[i][j] = \max(f[i - 1][j], f[i][j - v[i]] + w[i])$ 。  
**原理**：$f[i][j - v[i]]$ 已经包含了选 $0$ 个、$1$ 个……第 $i$ 种物品的情况，在此基础上再选一个第 $i$ 种物品（加 $w[i]$ ），就等价于朴素思路中选 $1$ 个、$2$ 个……的情况，从而优化了遍历 $k$ 的过程 。

## 五、代码实现
### （一）朴素版代码（Python）
```python
def complete_backpack_naive(N, V, v, w):
    # 初始化dp数组，f[i][j]表示前i个物品，容量j时的最大价值
    f = [[0] * (V + 1) for _ in range(N + 1)]  
    for i in range(1, N + 1):
        for j in range(1, V + 1):
            k = 0
            while k * v[i - 1] <= j:  # 遍历第i个物品选0到k个的情况
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i - 1]] + k * w[i - 1])
                k += 1
    return f[N][V]
```
**复杂度分析**：时间复杂度 $O(N \times V \times \frac{V}{v_{\min}})$（$v_{\min}$ 是物品最小体积 ），当 $V$ 较大时，复杂度很高，容易超时（TLE）。

### （二）优化版代码（Python）
```python
def complete_backpack_optimized(N, V, v, w):
    f = [0] * (V + 1)
    for i in range(1, N + 1):
        for j in range(v[i - 1], V + 1):  # 容量从v[i-1]开始，保证j - v[i-1] >=0
            f[j] = max(f[j], f[j - v[i - 1]] + w[i - 1])
    return f[V]
```
**优化点**：  
- 用一维数组滚动优化空间，通过调整循环顺序（从小到大遍历容量 $j$ ），利用 $f[j - v[i]]$ 已更新的状态（对应优化后的转移方程 $f[i][j] = \max(f[i - 1][j], f[i][j - v[i]] + w[i])$ ），省略了对 $k$ 的遍历，时间复杂度降为 $O(N \times V)$ ，效率大幅提升 。 

调用示例（以两种代码为例，数据需按需替换）：
```python
# 物品数量、背包容量
N, V = 3, 10  
# 物品体积、价值，索引0开始对应第1个物品
v = [2, 3, 5]  
w = [3, 4, 8]  
# 朴素版调用
print(complete_backpack_naive(N, V, v, w))  
# 优化版调用
print(complete_backpack_optimized(N, V, v, w))  
``` 


## 六、代码对比与复杂度  
| 版本       | 时间复杂度       | 空间复杂度     | 核心优化点                     |  
|------------|------------------|----------------|--------------------------------|  
| 朴素版     | $O(N \times V \times \frac{V}{v_{\text{min}}})$ | $O(N \times V)$ | 无优化，直接遍历所有选法       |  
| 优化版     | $O(N \times V)$                             | $O(V)$         | 一维数组 + 容量正序遍历，复用状态 |  


**总结**：完全背包问题的核心是动态规划状态转移的推导与优化。优化版通过**一维数组滚动**和**容量正序遍历**，避免了冗余计算，效率大幅提升，是实际解题的首选方案。