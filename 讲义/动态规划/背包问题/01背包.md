# 01背包问题笔记（基于题解整理）

## 一、问题特点与描述
- **核心特点**：每件物品仅能使用一次。
- **问题定义**：有N件物品和一个容量为V的背包，每件物品有对应的体积（v[i]）和价值（w[i]），要求在背包容量限制内，选择物品使得总价值最大。


## 二、动态规划解题思路
### 2.1 核心状态转移逻辑
将前i个物品的选法分为两类（确保不重复、不遗漏）：
1. **不选第i件物品**：最优解等同于前i-1件物品在容量j下的最优解，即 `f[i-1][j]`。
2. **选第i件物品**：需先预留第i件物品的体积，最优解为前i-1件物品在容量`j-v[i]`下的最优解加上第i件物品的价值，即 `f[i-1][j-v[i]] + w[i]`。

**状态转移方程**：  
`f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])`


## 三、代码实现
### 3.1 朴素解法（二维数组）
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N];  // f[i][j]表示前i件物品在容量j下的最大价值
int v[N], w[N];  // 物品体积和价值
int n, m;  // 物品数量和背包容量

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    // 遍历物品
    for (int i = 1; i <= n; i++) {
        // 遍历容量
        for (int j = 1; j <= m; j++) {
            // 初始化为不选第i件物品的情况
            f[i][j] = f[i - 1][j];
            // 若容量足够，考虑选第i件物品的情况
            if (j >= v[i]) {
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }

    cout << f[n][m] << endl;
    return 0;
}
```

#### 示例说明
假设有4件物品，背包容量为5，物品的体积和价值如下：
| 物品序号 | 体积(v[i]) | 价值(w[i]) |
|----------|------------|------------|
| 1        | 1          | 2          |
| 2        | 2          | 4          |
| 3        | 3          | 4          |
| 4        | 4          | 5          |

目标：在背包容量不超过5的情况下，选择物品使总价值最大。

## 一、二维数组解法求解过程
### 状态定义
`f[i][j]` 表示前i件物品在背包容量为j时的最大价值。

### 初始化
- 当i=0（无物品）时，`f[0][j] = 0`（任何容量下价值都为0）。
- 当j=0（容量为0）时，`f[i][0] = 0`（无法装任何物品）。


### 逐行计算（i从1到4，j从1到5）
#### 第1件物品（v=1，w=2）
- j=1：容量足够，`f[1][1] = max(f[0][1], f[0][0]+2) = max(0, 0+2) = 2`
- j=2：`f[1][2] = max(f[0][2], f[0][1]+2) = max(0, 0+2) = 2`
- j=3：`f[1][3] = 2`（同理，仅选第1件）
- j=4：`f[1][4] = 2`
- j=5：`f[1][5] = 2`

#### 第2件物品（v=2，w=4）
- j=1：容量不足（1<2），`f[2][1] = f[1][1] = 2`
- j=2：`max(f[1][2]=2, f[1][0]+4=4) → 4`
- j=3：`max(f[1][3]=2, f[1][1]+4=6) → 6`
- j=4：`max(f[1][4]=2, f[1][2]+4=6) → 6`
- j=5：`max(f[1][5]=2, f[1][3]+4=6) → 6`

#### 第3件物品（v=3，w=4）
- j=1：`f[3][1] = f[2][1] = 2`
- j=2：`f[3][2] = f[2][2] = 4`
- j=3：`max(f[2][3]=6, f[2][0]+4=4) → 6`
- j=4：`max(f[2][4]=6, f[2][1]+4=6) → 6`
- j=5：`max(f[2][5]=6, f[2][2]+4=8) → 8`（关键：选第2件+第3件，体积2+3=5，价值4+4=8）

#### 第4件物品（v=4，w=5）
- j=1：`f[4][1] = f[3][1] = 2`
- j=2：`f[4][2] = f[3][2] = 4`
- j=3：`f[4][3] = f[3][3] = 6`
- j=4：`max(f[3][4]=6, f[3][0]+5=5) → 6`
- j=5：`max(f[3][5]=8, f[3][1]+5=7) → 8`

### 结果
`f[4][5] = 8`，即最大价值为8。

最优解为选择物品2和3，总容量2+3=5，总价值4+4=8，与代码计算结果一致。


### 3.2 空间优化（一维数组）
#### 优化原理
- 二维数组中，`f[i][j]` 仅依赖上一层 `f[i-1][...]` 的数据，可压缩为一维数组 `f[j]`。
- 关键要求：**容量j必须逆序遍历**（从m到v[i]），避免覆盖上一层（i-1）的状态数据。

#### 为什么需要逆序遍历？
- 若正序遍历，计算 `f[j]` 时，`f[j-v[i]]` 可能已被当前层（i）更新，导致同一件物品被多次选择（违反0-1背包“仅用一次”的规则）。
- 逆序遍历确保 `f[j-v[i]]` 仍为上一层（i-1）的状态，符合状态转移逻辑。

### 状态定义
`f[j]` 表示当前考虑过的物品在容量j时的最大价值（初始全为0）。

### 遍历过程（逆序更新j）
#### 处理第1件物品（v=1，w=2）
- j=5→1：`f[j] = max(f[j], f[j-1]+2)`
- 更新后：`f = [0,2,2,2,2,2]`

#### 处理第2件物品（v=2，w=4）
- j=5→2：`f[j] = max(f[j], f[j-2]+4)`
  - j=5：`max(2, f[3]+4=6) → 6`
  - j=4：`max(2, f[2]+4=6) → 6`
  - j=3：`max(2, f[1]+4=6) → 6`
  - j=2：`max(2, f[0]+4=4) → 4`
- 更新后：`f = [0,2,4,6,6,6]`

#### 处理第3件物品（v=3，w=4）
- j=5→3：`f[j] = max(f[j], f[j-3]+4)`
  - j=5：`max(6, f[2]+4=8) → 8`
  - j=4：`max(6, f[1]+4=6) → 6`
  - j=3：`max(6, f[0]+4=4) → 6`
- 更新后：`f = [0,2,4,6,6,8]`

#### 处理第4件物品（v=4，w=5）
- j=5→4：`f[j] = max(f[j], f[j-4]+5)`
  - j=5：`max(8, f[1]+5=7) → 8`
  - j=4：`max(6, f[0]+5=5) → 6`
- 最终：`f = [0,2,4,6,6,8]`

### 结果
`f[5] = 8`，与二维解法一致。

#### 优化后代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N];  // 一维数组存储容量j下的最大价值
int v[N], w[N];
int n, m;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    // 遍历物品
    for (int i = 1; i <= n; i++) {
        // 逆序遍历容量（关键）
        for (int j = m; j >= v[i]; j--) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;
    return 0;
}
```


## 四、错误案例分析（正序遍历的问题）

在01背包问题的一维数组优化中，**必须逆序遍历背包容量**，而正向遍历会导致逻辑错误。下面通过具体案例说明正向求解的问题所在。


## 一、核心矛盾：01背包的约束与正向遍历的冲突
01背包的核心约束是**每件物品只能选择一次**，但正向遍历会破坏这一约束，导致物品被重复选取（相当于变成了“完全背包”的逻辑）。

- 一维数组中，`f[j]` 的更新依赖于 `f[j - v[i]]`（上一轮未更新的状态）。
- 正向遍历（从小到大枚举容量）时，`f[j - v[i]]` 可能已在本轮被更新，导致同一件物品被多次使用。


## 二、具体示例：正向遍历的错误过程
以之前的4件物品为例（物品1：体积1，价值2；背包容量5），单独分析处理第1件物品时的正向遍历错误：

### 初始状态
`f = [0, 0, 0, 0, 0, 0]`（容量0~5的初始价值均为0）。

### 正向遍历（j从1到5）处理第1件物品
- **j=1**：`f[1] = max(f[1], f[1-1] + 2) = max(0, 0+2) = 2`  
  （正确：选1件物品1，价值2）
- **j=2**：`f[2] = max(f[2], f[2-1] + 2) = max(0, 2+2) = 4`  
  （错误：此处用到的 `f[1]` 是本轮已更新的状态，相当于物品1被选了2次，体积1+1=2，价值2+2=4）
- **j=3**：`f[3] = max(f[3], f[3-1] + 2) = max(0, 4+2) = 6`  
  （错误：物品1被选了3次）
- **j=4**：`f[4] = 8`（物品1被选4次）
- **j=5**：`f[5] = 10`（物品1被选5次）

### 结果
正向遍历后 `f[5] = 10`，但这违反了“物品1只能选一次”的约束（实际最多只能选1次，价值2）。


## 三、错误根源：状态被“污染”
- 二维数组中，`f[i][j]` 依赖的是 `f[i-1][j - v[i]]`（上一轮状态），两者完全独立。
- 一维数组正向遍历中，`f[j - v[i]]` 已被本轮更新（属于第i层状态），导致计算 `f[j]` 时重复使用了第i件物品。
- 逆序遍历则确保 `f[j - v[i]]` 仍是上一轮（i-1层）的状态，符合01背包的“仅选一次”约束。


## 四、结论
一维正向遍历会错误地允许物品被多次选择，违背01背包的问题定义，因此必须采用**逆序遍历**才能得到正确结果。这也是01背包一维优化的核心易错点。


