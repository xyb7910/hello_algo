### 分组背包问题笔记
#### 一、题目描述
有 `n` 组物品，每组有若干个物品，每组内只能选一个物品（或不选）。背包容量为 `m`，每个物品有体积 `v` 和价值 `w`，求在背包容量限制下，能获得的最大价值。

#### 二、做题分析步骤
1. **状态定义**：设 `f[j]` 表示背包容量为 `j` 时，能获得的最大价值。
2. **遍历顺序**：先遍历组，再逆序遍历背包容量（避免同一组物品重复选），最后遍历组内物品。
3. **状态转移**：对每组物品，尝试将组内每个物品放入背包，更新最大价值。

#### 三、重点知识笔记
- **分组约束**：每组最多选一个，通过“组→容量→组内物品”的遍历顺序保证。
- **逆序遍历容量**：防止同一组内物品被多次选取（类似 01 背包的优化逻辑 ）。 
- **状态复用**：利用一维数组 `f` 滚动更新，优化空间复杂度。

#### 四、转移方程推理过程
1. **朴素思路**：对于第 `i` 组的第 `k` 个物品，若选它，需从“不选该组物品的状态 `f[j]`” 或 “选该物品（即容量为 `j - v[i][k]` 时的最大价值 + `w[i][k]`）”中选最大，即：  
   ```
   f[i][j] = max(f[i-1][j], f[i-1][j - v[i][k]] + w[i][k])
   ```  
   （`f[i][j]` 表示前 `i` 组、容量 `j` 时的最大价值 ）
2. **优化推导**：用一维数组优化后，逆序遍历容量 `j`，状态转移简化为：  
   ```
   f[j] = max(f[j], f[j - v[i][k]] + w[i][k])
   ```  
   逆序保证 `f[j - v[i][k]]` 是“未考虑当前组物品”的状态，符合分组选一个的约束。

#### 五、代码实现
##### 1. 朴素版（二维数组，便于理解状态）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110; 
int n, m;
int v[N][N], w[N][N], s[N]; 
int f[N][N]; 

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> s[i]; 
        for (int j = 0; j < s[i]; j++) 
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i++) { 
        for (int j = 0; j <= m; j++) { 
            f[i][j] = f[i - 1][j]; 
            for (int k = 0; k < s[i]; k++) { 
                if (j >= v[i][k]) 
                    f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

##### 2. 优化版（一维数组，空间更优）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110; 
int n, m;
int v[N][N], w[N][N], s[N]; 
int f[N]; 

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> s[i]; 
        for (int j = 0; j < s[i]; j++) 
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i++) { 
        for (int j = m; j >= 0; j--) { 
            for (int k = 0; k < s[i]; k++) { 
                if (j >= v[i][k]) 
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

**对比总结**：  
- 朴素版用二维数组 `f[i][j]` 显式区分“前 `i` 组”的状态，逻辑清晰但空间开销大。  
- 优化版通过一维数组 + 逆序遍历，压缩空间，执行效率更高，是实际竞赛常用写法。核心均利用分组遍历 + 状态转移，保证每组仅选一个物品 。 