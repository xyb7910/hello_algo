### **1. 选择排序（朴素版）**
**代码片段**：
```cpp
for (int i = 1; i <= n - 1; i++)
    for (int j = i + 1; j <= n; j++)
        if (a[i] > a[j])
            swap(a[i], a[j]);
```

**数学分析**：
1. **确定基本操作**：比较操作 `a[i] > a[j]` 和交换操作 `swap(a[i], a[j])`。
2. **计算比较次数**：
   - 外层循环 `i` 从 `1` 到 `n-1`，共执行 `n-1` 次。
   - 对于每个 `i`，内层循环 `j` 从 `i+1` 到 `n`，执行 `n-i` 次。
   - **总比较次数**：
     $$
     \sum_{i=1}^{n-1} (n-i) = \sum_{k=1}^{n-1} k = \frac{(n-1)n}{2} = \frac{n^2 - n}{2}
     $$
3. **计算交换次数**：
   - 最坏情况下（逆序数组），每次比较都触发交换，交换次数为 $\frac{n(n-1)}{2}$。
   - 最好情况下（已排序数组），交换次数为 $0$。
4. **时间复杂度**：
   - 忽略低阶项和常数系数，比较次数和交换次数均为 $O(n^2)$。


### **2. 选择排序（优化版）**
**代码片段**：
```cpp
for (int i = 1; i <= n - 1; i++) {
    int minj = i;
    for (int j = i + 1; j <= n; j++)
        if (a[minj] > a[j])
            minj = j;
    swap(a[i], a[minj]);
}
```

**数学分析**：
1. **确定基本操作**：比较操作 `a[minj] > a[j]` 和交换操作 `swap(a[i], a[minj])`。
2. **计算比较次数**：
   - 外层循环执行 `n-1` 次。
   - 对于每个 `i`，内层循环执行 `n-i` 次比较。
   - **总比较次数**：
     $$
     \sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2}
     $$
3. **计算交换次数**：
   - 无论输入如何，外层循环每次执行恰好一次交换，总交换次数为 $n-1$，即 $O(n)$。
4. **时间复杂度**：
   - 比较次数为 $O(n^2)$，交换次数为 $O(n)$，总时间复杂度由比较次数决定，为 $O(n^2)$。


### **3. 冒泡排序（朴素版）**
**代码片段**：
```cpp
for (int i = 1; i <= n - 1; i++)
    for (int j = 1; j <= n - i; j++)
        if (a[j] > a[j+1])
            swap(a[j], a[j+1]);
```

**数学分析**：
1. **确定基本操作**：比较操作 `a[j] > a[j+1]` 和交换操作 `swap(a[j], a[j+1])`。
2. **计算比较次数**：
   - 外层循环 `i` 从 `1` 到 `n-1`，共执行 `n-1` 次。
   - 对于每个 `i`，内层循环 `j` 从 `1` 到 `n-i`，执行 `n-i` 次。
   - **总比较次数**：
     $
     \sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2}
     $
3. **计算交换次数**：
   - 最坏情况下（逆序数组），每次比较都触发交换，交换次数为 $\frac{n(n-1)}{2}$。
   - 最好情况下（已排序数组），交换次数为 $0$。
4. **时间复杂度**：
   - 比较次数和最坏交换次数均为 $O(n^2)$。


### **4. 冒泡排序（优化版）**
**代码片段**：
```cpp
for (int i = 1; i <= n - 1; i++) {
    bool f = false;
    for (int j = 1; j <= n - i; j++)
        if (a[j] > a[j+1]) {
            swap(a[j], a[j+1]);
            f = true;
        }
    if (!f) break;
}
```

**数学分析**：
1. **确定基本操作**：比较操作、交换操作和标志变量 `f` 的更新。
2. **最好情况（已排序数组）**：
   - 第一次遍历执行 `n-1` 次比较，未发生交换，`f` 保持 `false`，算法终止。
   - **总比较次数**：$n-1$，即 $O(n)$。
   - **总交换次数**：$0$。
3. **最坏情况（逆序数组）**：
   - 每次遍历需要完整比较，总比较次数为：
     $
     \sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2}
     $
   - 总交换次数同样为 $\frac{n(n-1)}{2}$。
4. **平均情况**：
   - 假设输入随机，平均需要 $\frac{n-1}{2}$ 次遍历。
   - **总比较次数**：
     $$
     \sum_{i=1}^{\frac{n-1}{2}} (n-i) \approx \frac{n^2}{4} = O(n^2)
     $$


### **关键数学公式总结**
1. **等差数列求和**：
   $$
   \sum_{k=1}^{m} k = \frac{m(m+1)}{2}
   $$
   当 $m = n-1$ 时，结果为 $\frac{n(n-1)}{2}$，对应 $O(n^2)$$。

2. **等比数列求和**：
   $$
   \sum_{k=0}^{m} a^k = \frac{a^{m+1} - 1}{a - 1} \quad (a \neq 1)
   $$
   常用于分析分治算法（如快速排序、归并排序），当 $a=2$ 且 $m=\log n$ 时，结果为 $O(n)$。

3. **对数函数性质**：
   - $\log(n^k) = k \log n$
   - $\log(mn) = \log m + \log n$
   常用于分析递归算法的时间复杂度。


### **总结**
通过数学公式推导，我们得出：
- **选择排序**：无论输入如何，时间复杂度均为 $O(n^2)$，但优化版减少了交换次数。
- **冒泡排序**：朴素版时间复杂度为 $O(n^2)$，优化版在已排序数组上可达 $O(n)$。