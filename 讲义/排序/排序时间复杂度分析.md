### **时间复杂度的基本概念**
时间复杂度通常用大O符号（Big O notation）表示，它描述的是算法在**最坏情况下**的渐近上界。具体来说：
- **O(1)**：常数时间，算法执行时间与输入规模无关。
- **O(log n)**：对数时间，输入规模增大时，执行时间仅对数级增长。
- **O(n)**：线性时间，执行时间与输入规模成正比。
- **O(n log n)**：线性对数时间，常见于高效排序算法。
- **O(n²)**：平方时间，执行时间与输入规模的平方成正比。
- **O(2ⁿ)**：指数时间，输入规模增大时，执行时间呈指数级增长。


### **计算公式与分析方法**
计算时间复杂度的核心是分析算法中**基本操作的执行次数**与输入规模的关系。以下是具体步骤：

#### 1. **确定基本操作**
基本操作是算法中最核心的执行步骤，通常是：
- 算术运算（如加法、乘法）
- 比较操作（如`a > b`）
- 赋值语句（如`a = b`）
- 函数调用等

#### 2. **分析执行次数**
通过代码结构分析基本操作的执行次数，通常需要关注：
- **循环结构**：循环次数与输入规模的关系。
- **嵌套循环**：总次数为各层循环次数的乘积。
- **递归调用**：递归深度与每次递归的操作次数。

#### 3. **简化表达式**
保留最高阶项，忽略常数系数和低阶项。例如：
- `3n² + 5n + 7` → `O(n²)`
- `n log n + 2n` → `O(n log n)`


### **常见排序算法的时间复杂度分析**

#### **1. 选择排序（朴素版与优化版）**
```cpp
for (int i = 1; i <= n - 1; i++)
    for (int j = i + 1; j <= n; j++)
        if (a[i] > a[j]) 
            swap(a[i], a[j]);
```
- **分析**：
  - 外层循环执行 `n-1` 次。
  - 内层循环对每个 `i` 执行 `n-i` 次。
  - 总比较次数为：`(n-1) + (n-2) + ... + 1 = n(n-1)/2`。
  - **时间复杂度**：`O(n²)`（忽略常数系数 `1/2`）。

#### **2. 冒泡排序（朴素版）**
```cpp
for (int i = 1; i <= n - 1; i++)
    for (int j = 1; j <= n - i; j++)
        if (a[j] > a[j+1])
            swap(a[j], a[j+1]);
```
- **分析**：
  - 外层循环执行 `n-1` 次。
  - 内层循环对每个 `i` 执行 `n-i` 次。
  - 总比较次数同样为：`n(n-1)/2`。
  - **时间复杂度**：`O(n²)`。

#### **3. 冒泡排序（优化版）**
```cpp
for (int i = 1; i <= n - 1; i++) {
    bool f = false;
    for (int j = 1; j <= n - i; j++)
        if (a[j] > a[j+1]) {
            swap(a[j], a[j+1]);
            f = true;
        }
    if (!f) break;
}
```
- **分析**：
  - **最好情况**（数组已有序）：内层循环执行 `n-1` 次后，`f` 仍为 `false`，算法提前终止。时间复杂度 **O(n)**。
  - **最坏情况**（逆序数组）：执行完整的 `n(n-1)/2` 次比较。时间复杂度 **O(n²)**。


### **递归算法的时间复杂度（示例）**
递归算法通常使用**递归方程**或**主定理**分析。例如，快速排序的时间复杂度分析：

```cpp
void quickSort(int arr[], int left, int right) {
    if (left < right) {
        int pivot = partition(arr, left, right);
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }
}
```
- **分析**：
  - **平均情况**：每次划分将数组分为两部分，递归深度为 `O(log n)`，每层处理 `O(n)` 元素。总时间复杂度 **O(n log n)**。
  - **最坏情况**（如已排序数组）：每次划分极不平衡，递归深度为 `O(n)`，总时间复杂度 **O(n²)**。


### **总结**
1. **循环结构**：总次数 = 各层循环次数的乘积。
2. **嵌套循环**：关注内外层循环的依赖关系（如是否独立）。
3. **递归算法**：通过递归方程或主定理求解。
4. **简化原则**：保留最高阶项，忽略常数系数。

通过以上方法，你可以系统地分析任何算法的时间复杂度。在实际应用中，时间复杂度越低的算法，在处理大规模数据时效率越高。