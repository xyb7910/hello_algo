### 选择排序（Selection Sort）

**算法思想**  
选择排序的核心思想是每次从未排序部分中选出最小（或最大）的元素，与未排序部分的第一个元素交换位置，逐步将数组划分为已排序和未排序两部分。

**执行流程**  
1. 初始时，整个数组视为未排序部分。
2. 在未排序部分中找到最小元素，与未排序部分的第一个元素交换。
3. 将已排序部分的边界向右扩展一个位置。
4. 重复步骤2-3，直到整个数组有序。

**朴素版代码分析**  
```cpp
for (int i = 1; i <= n - 1; i ++)
    for (int j = i + 1; j <= n; j ++)
    {
        if(a[i] > a[j])
            swap(a[i], a[j]);
    }
```
- **比较次数**：固定为 $O(n^2)$，无论输入数据如何。
- **交换次数**：最坏情况下为 $O(n^2)$，每次发现更小元素都进行交换。
- **时间复杂度**：$O(n^2)$

**优化版代码分析**  
```cpp
for (int i = 1; i <= n - 1; i ++) {
    int minj = i;
    for (int j = i + 1; j <= n; j ++)
    {
        if(a[minj] > a[j]) minj = j;
    }
    swap(a[i], a[minj]);
}
```
- **比较次数**：仍为 $O(n^2)$，但减少了不必要的交换。
- **交换次数**：优化为 $O(n)$，每次遍历仅交换一次。
- **时间复杂度**：$O(n^2)$，但实际性能略优于朴素版。


### 冒泡排序（Bubble Sort）

**算法思想**  
冒泡排序重复遍历数组，比较相邻元素并交换顺序错误的对，每一轮遍历将当前最大元素"冒泡"到数组末尾。

**执行流程**  
1. 从数组头部开始，比较相邻元素。
2. 如果顺序错误（如前一个元素大于后一个），则交换它们。
3. 重复步骤1-2，直到遍历完整个数组。
4. 每轮遍历后，未排序部分的最大元素会被放置到正确位置。
5. 重复上述过程，直到所有元素有序。

**朴素版代码分析**  
```cpp
for (int i = 1; i <= n - 1; i ++) {
    for (int j = 1; j <= n - i; j ++)
    {
        if(a[j] > a[j + 1]) swap(a[j], a[j + 1]); 
    }
}
```
- **比较次数**：固定为 $O(n^2)$。
- **交换次数**：最坏情况下为 $O(n^2)$。
- **时间复杂度**：$O(n^2)$
- **特点**：即使数组已经有序，仍会执行完整的 $n(n-1)/2$ 次比较。

**优化版代码分析**  
```cpp
for (int i = 1; i <= n - 1; i ++) {
    bool f = false;
    for (int j = 1; j <= n - i; j ++)
    {
        if(a[j] > a[j + 1]) 
        {
            swap(a[j], a[j + 1]);
            f = true;
        }
    }
    if(f == false) break;
}
```
- **比较次数**：最坏情况下 $O(n^2)$，但对于接近有序的数组可降至 $O(n)$。
- **交换次数**：最坏情况下 $O(n^2)$，但提前终止机制可显著减少实际交换次数。
- **时间复杂度**：最坏 $O(n^2)$，最好 $O(n)$（当数组已排序时）。
- **哨兵变量 `f` 的作用**：检测本轮是否发生交换，若无交换则说明数组已有序，提前终止算法。


### 总结对比

| 算法       | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|------------|----------------|----------------|----------------|------------|--------|
| 选择排序   | $O(n^2)$   | $O(n^2)$   | $O(n^2)$   | $O(1)$  | 不稳定 |
| 冒泡排序   | $O(n)$     | $O(n^2)$   | $O(n^2)$   | $O(1)$  | 稳定   |

**适用场景**  
- 选择排序：数据规模较小时简单实用，交换次数少。
- 冒泡排序：适合数据基本有序的情况，优化版在这种场景下效率较高。